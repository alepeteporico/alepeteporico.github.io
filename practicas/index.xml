<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Practicas on Alepetepórico Blog</title>
    <link>https://alepeteporico.github.io/practicas/</link>
    <description>Recent content in Practicas on Alepetepórico Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 29 May 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://alepeteporico.github.io/practicas/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>DRBD y OCFS2</title>
      <link>https://alepeteporico.github.io/practicas/drb_ocfs2/</link>
      <pubDate>Sun, 29 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/drb_ocfs2/</guid>
      <description>Configura un escenario con dos máquinas. Cada una tiene que tener dos discos adicionales (tamaño 1Gb para que la sincronización sea rápida).  Configura en modo Single-primary el recurso wwwdata.  Primero debemos instalar el paquete necesario para usar DRBD en las dos máquinas.  vagrant@maquina1:~$ sudo apt install drbd-utils  Ahora para crear este recurso lo hacemos creando un fichero en /etc/drbd.d/ al que llamaremos wwwdata.res  resource wwwdata { protocol C; meta-disk internal; device /dev/drbd1; syncer { verify-alg sha1; } net { allow-two-primaries; } on maquina1 { disk /dev/vdb; address 192.</description>
    </item>
    
    <item>
      <title>Poblar un directorio LDAP desde un fichero CSV</title>
      <link>https://alepeteporico.github.io/practicas/ldap_csv/</link>
      <pubDate>Fri, 20 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/ldap_csv/</guid>
      <description>Crear entre todos los alumnos de la clase que vayan a hacer esta tarea un fichero CSV que incluya información personal de cada uno incluyendo los siguientes datos:
  Nombre
  Apellidos
  Dirección de correo electrónico
  Nombre de usuario
  Clave pública ssh
    Otro fichero con la siguiente información de los alumnos:
  Hostname
  IPv4</description>
    </item>
    
    <item>
      <title>Usuarios, Grupos y ACLs en LDAP</title>
      <link>https://alepeteporico.github.io/practicas/ldap_uga/</link>
      <pubDate>Fri, 20 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/ldap_uga/</guid>
      <description>Crea 10 usuarios con los nombres que prefieras en LDAP, esos usuarios deben ser objetos de los tipos posixAccount e inetOrgPerson. Estos usuarios tendrán un atributo userPassword. dn: uid=stark,ou=Usuarios,dc=alexgv,dc=gonzalonazareno,dc=org objectClass: posixAccount objectClass: inetOrgPerson objectClass: top cn: stark gidNumber: 2001 homeDirectory: /home/stark loginShell: /bin/bash sn: stark uid: stark uidNumber: 2001 userPassword: {SSHA}loVCFjl442fnkpIZC05Ht+8OwLsgF0Ua dn: uid=rogers,ou=Usuarios,dc=alexgv,dc=gonzalonazareno,dc=org objectClass: posixAccount objectClass: inetOrgPerson objectClass: top cn: rogers gidNumber: 2002 homeDirectory: /home/rogers loginShell: /bin/bash sn: rogers uid: rogers uidNumber: 2002 userPassword: {SSHA}gLim3ka1uQnZtFCMBoD0+NKmQ88/7f+d dn: uid=banner,ou=Usuarios,dc=alexgv,dc=gonzalonazareno,dc=org objectClass: posixAccount objectClass: inetOrgPerson objectClass: top cn: banner gidNumber: 2003 homeDirectory: /home/banner loginShell: /bin/bash sn: banner uid: banner uidNumber: 2003 userPassword: {SSHA}R28hwHBG+MeisvkGM3qS7q049d8p6QO1 dn: uid=romanof,ou=Usuarios,dc=alexgv,dc=gonzalonazareno,dc=org objectClass: posixAccount objectClass: inetOrgPerson objectClass: top cn: romanof gidNumber: 2004 homeDirectory: /home/romanof loginShell: /bin/bash sn: romanof uid: romanof uidNumber: 2004 userPassword: {SSHA}r4NOljTbgWSfO1r4daswgbBDhlLtwMwd dn: uid=burton,ou=Usuarios,dc=alexgv,dc=gonzalonazareno,dc=org objectClass: posixAccount objectClass: inetOrgPerson objectClass: top cn: burton gidNumber: 2005 homeDirectory: /home/burton loginShell: /bin/bash sn: burton uid: burton uidNumber: 2005 userPassword: {SSHA}n8aeZpDwycwusGlKWl56MuTXARrAWhyM dn: uid=thor,ou=Usuarios,dc=alexgv,dc=gonzalonazareno,dc=org objectClass: posixAccount objectClass: inetOrgPerson objectClass: top cn: thor gidNumber: 2006 homeDirectory: /home/thor loginShell: /bin/bash sn: thor uid: thor uidNumber: 2006 userPassword: {SSHA}m20Ph+8uSwScFHcJ6iVpgimoiKawWuc3 dn: uid=strange,ou=Usuarios,dc=alexgv,dc=gonzalonazareno,dc=org objectClass: posixAccount objectClass: inetOrgPerson objectClass: top cn: strange gidNumber: 2007 homeDirectory: /home/strange loginShell: /bin/bash sn: strange uid: strange uidNumber: 2007 userPassword: {SSHA}UpziawVa6CL9Kk/g7gVzFRQ4MJWBDFKP dn: uid=parker,ou=Usuarios,dc=alexgv,dc=gonzalonazareno,dc=org objectClass: posixAccount objectClass: inetOrgPerson objectClass: top cn: parker gidNumber: 2008 homeDirectory: /home/parker loginShell: /bin/bash sn: parker uid: parker uidNumber: 2008 userPassword: {SSHA}Px8NYV9wWlc/JxmUWaGaBV28KSucLIYt dn: uid=furia,ou=Usuarios,dc=alexgv,dc=gonzalonazareno,dc=org objectClass: posixAccount objectClass: inetOrgPerson objectClass: top cn: furia gidNumber: 2009 homeDirectory: /home/furia loginShell: /bin/bash sn: furia uid: furia uidNumber: 2009 userPassword: {SSHA}8VRwZX4ts0fe8KBT58h3ywzpj+EEShfV dn: uid=maximof,ou=Usuarios,dc=alexgv,dc=gonzalonazareno,dc=org objectClass: posixAccount objectClass: inetOrgPerson objectClass: top cn: maximof gidNumber: 2010 homeDirectory: /home/maximof loginShell: /bin/bash sn: maximof uid: maximof uidNumber: 2010 userPassword: {SSHA}t1Oa8gRUcI6kfJvVfNpNdMeMXs+05l1K  Ejecutamos este fichero.</description>
    </item>
    
    <item>
      <title>LDAP en alta disponibilidad</title>
      <link>https://alepeteporico.github.io/practicas/ldap_ad/</link>
      <pubDate>Tue, 17 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/ldap_ad/</guid>
      <description>Vamos a instalar un servidor LDAP en ares que va a actuar como servidor secundario o de respaldo del servidor LDAP instalado en apolo, para ello habrá que seleccionar un modo de funcionamiento y configurar la sincronización entre ambos directorios, para que los cambios que se realicen en uno de ellos se reflejen en el otro. Metodo usado: LDAP Syncy Replication   Usaremos este metodo ya que podemos adecuarlo a las necesidades de nuestro escenario como queramos debido a las diferentes útilidades que tiene.</description>
    </item>
    
    <item>
      <title>LDAPs</title>
      <link>https://alepeteporico.github.io/practicas/ldaps/</link>
      <pubDate>Tue, 17 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/ldaps/</guid>
      <description>Para usar la configuración segura de ldap primero debemos tener los certificados correspondientes, primero creamos una clave privada con openssl.  root@apolo:~# openssl genrsa 4096 &amp;gt; /etc/ssl/private/apoloalexgv.key  Y usando esa clave creamos un certificado que deberá ser firmado por la unidad certificadora del gonzalo nazareno en nuestro caso.  root@apolo:~# openssl req -new -key /etc/ssl/private/apoloalexgv.key -out /root/apoloalexgv.csr  Con la clave, el certificado firmado y el certificado del gonzalo nazareno que descargaremos de gestiona tendremos todos los certificados necesarios, veamos donde se ubica cada uno.</description>
    </item>
    
    <item>
      <title>Despliegue de CMS java</title>
      <link>https://alepeteporico.github.io/practicas/cms_java/</link>
      <pubDate>Wed, 04 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/cms_java/</guid>
      <description>Hemos elegido la aplicación Guacamole la cual permite administrar de forma remota el sistema donde lo instalemos mediante una interfaz web usando protocolos como: ssh, rdp o vnc.
  Para empezar instalaremos la paquetería necesaria.
  vagrant@cmsjava:~$ sudo apt install build-essential libcairo2-dev libjpeg62-turbo-dev libpng-dev libtool-bin libossp-uuid-dev libavcodec-dev libavformat-dev libswscale-dev freerdp2-dev libpango1.0-dev libssh2-1-dev libtelnet-dev libvncserver-dev libwebsockets-dev libpulse-dev libvorbis-dev libwebp-dev  Descargaremos la aplicación del sitio oficial.  vagrant@cmsjava:~$ wget -O &#39;guacamole-server-1.</description>
    </item>
    
    <item>
      <title>HTTPS OVH</title>
      <link>https://alepeteporico.github.io/practicas/https_ovh/</link>
      <pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/https_ovh/</guid>
      <description>Explica los pasos fundamentales para la creación del certificado. Especificando los campos que has rellenado en el fichero CSR.  Para este cometido usaremos el servicio letsencrypt, esta unidad certificadora hace use del protocolo ACME que lleva a cabo dos sencillos pasos mediante un agente llamadao certbot los pasos son:   Validación del dominio. Tenemos que demostrar que somos administradores del dominio en el que queremos generar este certificado, esto se puede hacer de dos formas:    Creando un fichero de configuración en una ruta determinada, si la autoridad certificadora puede acceder por el puerto 80 y verificar este fichero y validar las firmas de las claves que se generarían para hacer dicha conexión, entonces verificará que somos administradores del dominio.</description>
    </item>
    
    <item>
      <title>Cortafuegos perimetral sobre el escenario</title>
      <link>https://alepeteporico.github.io/practicas/cortafuegos/</link>
      <pubDate>Mon, 21 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/cortafuegos/</guid>
      <description>Política por defecto DROP para las cadenas INPUT, FORWARD y OUTPUT.  iptables -P INPUT DROP iptables -P OUTPUT DROP iptables -P FORWARD DROP  La máquina Zeus tiene un servidor ssh escuchando por el puerto 22, pero al acceder desde el exterior habrá que conectar al puerto 2222.  iptables -t nat -A PREROUTING -p tcp --dport 2222 -i eth0 -j DNAT --to 172.22.0.169:22 iptables -A INPUT -i eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT iptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT alejandrogv@AlejandroGV:~$ ssh -A debian@172.</description>
    </item>
    
    <item>
      <title>Instalación/migración de aplicaciones web PHP eb tu VPS</title>
      <link>https://alepeteporico.github.io/practicas/cms_php_vps/</link>
      <pubDate>Sun, 20 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/cms_php_vps/</guid>
      <description>Drupal  Primero migraremos la aplicación de drupal que tenemos instalada localmente. para ello vamos a migrar la base de datos.  root@cmsagv:~# mysqldump drupal &amp;gt; ./backup.sql  Migramos la aplicación  alejandrogv@AlejandroGV:~$ scp drupal/ debian@mrrobot.alejandrogv.site/home/debian/  Seguidamente nos iremos a nuestra VPS donde instalaremos mariadb y crearemos una base de datos y un usuario con privilegios sobre ella.  MariaDB [(none)]&amp;gt; CREATE DATABASE drupal; Query OK, 1 row affected (0.</description>
    </item>
    
    <item>
      <title>Servidor DHCP 2022</title>
      <link>https://alepeteporico.github.io/practicas/dhcp_2022/</link>
      <pubDate>Wed, 16 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/dhcp_2022/</guid>
      <description>Creación del escenario  Primero creamos la imagen inicial.  virt-install --connect qemu:///system --cdrom /home/alejandrogv/Escritorio/ISOS/debian-11.1.0-amd64-netinst.iso --network network=bridge --name servidor --memory 1024 --vcpus 1 --disk size=10  Ahora con el volumen que se ha creado crearemos las imagenes de los clientes y el servidor.  sudo qemu-img create -b /var/lib/libvirt/images/servidor.qcow2 -f qcow2 /var/lib/libvirt/images/server.qcow2 sudo qemu-img create -b /var/lib/libvirt/images/servidor.qcow2 -f qcow2 /var/lib/libvirt/images/cliente1.qcow2 sudo qemu-img create -b /var/lib/libvirt/images/servidor.qcow2 -f qcow2 /var/lib/libvirt/images/cliente2.qcow2  Y creamos las máquinas a partir de estas imagenes  sudo virt-install --connect qemu:///system --name server --memory 1024 --vcpus 1 --disk /var/lib/libvirt/images/server.</description>
    </item>
    
    <item>
      <title>Copias de seguridad con bacula</title>
      <link>https://alepeteporico.github.io/practicas/copias/</link>
      <pubDate>Mon, 14 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/copias/</guid>
      <description>Usaremos la herramienta bacula para realizar nuestro sistema de copias de seguridad, por supuesto el primer paso que debemos tomar es instalar el paquete de bacula, instalaremos el cliente en todas las máquinas de nuestro escenario, aunque usaremos zeus para alojar las copias de seguridad.
  Para alojar las copias hemos añadido dos discos que vamos a montar en RAID.
  debian@zeus:~$ df -h Filesystem Size Used Avail Use% Mounted on /dev/md0 9.</description>
    </item>
    
    <item>
      <title>SElinux</title>
      <link>https://alepeteporico.github.io/practicas/selinux/</link>
      <pubDate>Fri, 18 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/selinux/</guid>
      <description>En esta práctica vamos a habilitar SELinux en un servidor rocky, en este servidor tendremos alojados un SAMBA y NFS, tendremos que asegurarnos que esto servicios funcionan correctamente con SELinux activado y nuestros clientes pueden usarlos sin problemas.
  Hemos instalado y configurado un servidor samba y nfs en una máquina servidor.
  [vagrant@server ~]$ sudo systemctl status smb.service ● smb.service - Samba SMB Daemon Loaded: loaded (/usr/lib/systemd/system/smb.</description>
    </item>
    
    <item>
      <title>Recolección de logs mediante journald</title>
      <link>https://alepeteporico.github.io/practicas/logs/</link>
      <pubDate>Fri, 04 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/logs/</guid>
      <description>Vamos a usar el paquete systemd-journal-remote primero deberemos instalarlo en nuestro servidor principal, hemos escogido ares y también deberemos instalarlo en nuestros clientes.  usuario@ares:~$ sudo apt install systemd-journal-remote  Vamos a habilitar dos componentes de systemd necesarios para recibir los logs.  usuario@ares:~$ sudo systemctl enable --now systemd-journal-remote.socket Created symlink /etc/systemd/system/sockets.target.wants/systemd-journal-remote.socket -&amp;gt; /lib/systemd/system/systemd-journal-remote.socket. usuario@ares:~$ sudo systemctl enable systemd-journal-remote.service  Y en los clientes también debemos habilitar uno.  [hera@hera ~]$ sudo systemctl enable systemd-journal-upload.</description>
    </item>
    
    <item>
      <title>Aplicación php en docker</title>
      <link>https://alepeteporico.github.io/practicas/docker_bookmedik/</link>
      <pubDate>Wed, 02 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/docker_bookmedik/</guid>
      <description>Creación de una imagen docker con una aplicación web desde una imagen base   url del repositorio GitHub donde tengas los ficheros necesarios para hacer la construcción de la imagen.
  Imagen docker con la aplicación desde una imagen base de debian o ubuntu. En el registro de tu entorno de desarrollo.
  alejandrogv@AlejandroGV:~/docker/docker_php$ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE alejandro/bookmedik v1 04c149347bc6 2 days ago 257MB Despliegue en el entorno de desarrollo  Instrucción para ver los dos contenedores del escenario funcionando.</description>
    </item>
    
    <item>
      <title>Correo en la VPS</title>
      <link>https://alepeteporico.github.io/practicas/correo/</link>
      <pubDate>Wed, 02 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/correo/</guid>
      <description>Documenta una prueba de funcionamiento, donde envíes desde tu servidor local al exterior. Muestra el log donde se vea el envío. Muestra el correo que has recibido. Muestra el registro SPF.  debian@mrrobot:~$ mail tojandro@gmail.com Cc: Subject: prueba desde vps debian@mrrobot:~$ cat /var/log/mail.log Feb 2 07:39:58 mrrobot postfix/pickup[915259]: E42DCA0AB9: uid=1000 from=&amp;lt;debian@mrrobot.alejandrogv.site&amp;gt; Feb 2 07:39:58 mrrobot postfix/cleanup[916025]: E42DCA0AB9: message-id=&amp;lt;20220202073958.E42DCA0AB9@mrrobot.alejandrogv.site&amp;gt; Feb 2 07:39:58 mrrobot postfix/qmgr[915260]: E42DCA0AB9: from=&amp;lt;debian@mrrobot.alejandrogv.site&amp;gt;, size=375, nrcpt=1 (queue active) Feb 2 07:39:59 mrrobot postfix/smtp[916027]: connect to gmail-smtp-in.</description>
    </item>
    
    <item>
      <title>Contenedores LXC</title>
      <link>https://alepeteporico.github.io/practicas/lxc/</link>
      <pubDate>Wed, 19 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/lxc/</guid>
      <description>Creación   Crearemos la primera máquina de nuestro escenario, será un contenedor LXC llamado router. Este contenedor se creará a partir de la plantilla Debian Bullseye. Este contenedor tendrá dos interfaces de red: la primera conectada a una red pública (bridge br0). Por esta interfaz el contenedor tendrá acceso a internet. Además estará conectada la bridge de un red muy aislada que crearás con virsh y tendrá como dirección IP la 10.</description>
    </item>
    
    <item>
      <title>iSCSI</title>
      <link>https://alepeteporico.github.io/practicas/iscsi/</link>
      <pubDate>Thu, 06 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/iscsi/</guid>
      <description>Configura un escenario con vagrant o similar que incluya varias máquinas que permita realizar la configuración de un servidor iSCSI y dos clientes (uno linux y otro windows). Explica de forma detallada en la tarea los pasos realizados.   Crea un target con una LUN y conéctala a un cliente GNU/Linux. Explica cómo escaneas desde el cliente buscando los targets disponibles y utiliza la unidad lógica proporcionada, formateándola si es necesario y montándola.</description>
    </item>
    
    <item>
      <title>Interconexión de servidores de bases de datos</title>
      <link>https://alepeteporico.github.io/practicas/interconexion/</link>
      <pubDate>Mon, 03 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/interconexion/</guid>
      <description>Realizar un enlace entre dos servidores de bases de datos ORACLE, explicando la configuración necesaria en ambos extremos y demostrando su funcionamiento.
  Realizar un enlace entre dos servidores de bases de datos Postgres, explicando la configuración necesaria en ambos extremos y demostrando su funcionamiento.
  Realizar un enlace entre un servidor ORACLE y otro Postgres o MySQL empleando Heterogeneus Services, explicando la configuración necesaria en ambos extremos y demostrando su funcionamiento.</description>
    </item>
    
    <item>
      <title>DNS, servidor web y base de datos</title>
      <link>https://alepeteporico.github.io/practicas/server_web_bbdd_dns/</link>
      <pubDate>Fri, 10 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/server_web_bbdd_dns/</guid>
      <description>Servidor DNS  Configuramos el fichero &amp;ldquo;/etc/bind/named.conf.options&amp;rdquo; y añadimos las siguientes líneas:   listen-on { any; }; allow-transfer { none; }; recursion yes; allow-recursion { any; }; *Configuramos el DNS local, la DMZ y externa en el fichero de configuración /etc/bind/named.conf.local:
view interna { match-clients { 10.0.1.0/24; 127.0.0.1; }; allow-recursion { any; }; zone &amp;quot;alexgv.gonzalonazareno.org&amp;quot; { type master; file &amp;quot;db.alexgv.interna&amp;quot;; }; zone &amp;quot;1.0.10.in-addr-arpa&amp;quot; { type master; file &amp;quot;db.1.0.10&amp;quot;; }; zone &amp;quot;16.</description>
    </item>
    
    <item>
      <title>VPN</title>
      <link>https://alepeteporico.github.io/practicas/vpn/</link>
      <pubDate>Thu, 09 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/vpn/</guid>
      <description>VPN de acceso remoto con OpenVPN y certificados x509  Tenemos dos equipos en vagrant a los que queremos configurarles una conexión VPN. empezemos con el servidor, este está conectado a una red 10.99.99.0/24 a parte de la red que usamos para conectarnos a esta y una interna.  vagrant@servidor:~$ ip a 1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.</description>
    </item>
    
    <item>
      <title>Btrfs</title>
      <link>https://alepeteporico.github.io/practicas/btrfs/</link>
      <pubDate>Thu, 02 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/btrfs/</guid>
      <description>Tenemos una maquina con varios discos asociados, lo primero que haremos será instalar la paquetería necesaria para el uso de este sistema de archivos.  vagrant@maquina1:~$ sudo apt install btrfs-progs arch-install-scripts  Montamos en la tabla de particiones los nuevos discos.  vagrant@maquina1:~$ sudo cfdisk -z /dev/vdb vagrant@maquina1:~$ sudo cfdisk -z /dev/vdc vagrant@maquina1:~$ sudo cfdisk -z /dev/vdd vagrant@maquina1:~$ sudo cfdisk -z /dev/vde  Y vamos a crear el sisitema de ficheros de cada una.</description>
    </item>
    
    <item>
      <title>Certificados Digitales</title>
      <link>https://alepeteporico.github.io/practicas/certficiados/</link>
      <pubDate>Mon, 22 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/certficiados/</guid>
      <description>Primero obtendremos nuestro certificado digital en la sede electrónica siguiendo todos los pasos que se nos indican.
  Una vez tengamos nuestro certificado digital podemos importarlo a cualquier navegador, en mi caso quiero importarlo a un navegador firefox que tengo en mi sistema debian 10. Para ello nos dirigiremos a preferencias &amp;gt; Privaciad y Seguridad &amp;gt; Certificados &amp;gt; Ver certificados aquí aparecerá una vetana emergente donde podremos ver todos los certificados guardados que tenemos.</description>
    </item>
    
    <item>
      <title>Integridad, firmas y autentificación</title>
      <link>https://alepeteporico.github.io/practicas/firmas/</link>
      <pubDate>Thu, 18 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/firmas/</guid>
      <description>Tarea 1:  Firmamos un fichero que enviaremos a nuestros compañeros para que comprueben nuestra firma:  alejandrogv@AlejandroGV:~/Descargas$ gpg --output fichero.sign --sign fichero.txt  He enviado un archivo firmado a un compañero que dispone de mi clave pública, los dos hemos verificado la firma.  alejandrogv@AlejandroGV:~/Descargas$ gpg --verify p2pdf.pdf.sign gpg: Firmado el jue 18 nov 2021 12:25:18 CET gpg: usando RSA clave 47742CCB469EB70E132966EDEDA6F79F602CACBD gpg: Firma correcta de &amp;quot;Daniel Miguel Mesa Mejias &amp;lt;danimesamejias@gmail.</description>
    </item>
    
    <item>
      <title>Despliegue de una aplicación python</title>
      <link>https://alepeteporico.github.io/practicas/despliegue_python/</link>
      <pubDate>Tue, 16 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/despliegue_python/</guid>
      <description>Vamos a desarrollar la aplicación del tutorial de django 3.1. Vamos a configurar tu equipo como entorno de desarrollo para trabajar con la aplicación.   Realizamos un fork de la aplicación añadiendola a nuestros repositorios y seguidamente lo clonaremos en nuestra maquina:  alejandrogv@AlejandroGV:~/Escritorio/ASIR/IWEB/despliegue_python$ git clone git@github.com:alepeteporico/django_tutorial.git  Crearemos el entorno virtual donde instalaremos las dependencias necesarias para hacer funcionar nuestra aplicación.  alejandrogv@AlejandroGV:~/Escritorio/ASIR/IWEB$ python3 -m venv django (django) alejandrogv@AlejandroGV:~/Escritorio/ASIR/IWEB$ pip install -r despliegue_python/django_tutorial/requirements.</description>
    </item>
    
    <item>
      <title>Cifrado asimétrico con gpg y openssl</title>
      <link>https://alepeteporico.github.io/practicas/asimetrico/</link>
      <pubDate>Thu, 11 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/asimetrico/</guid>
      <description>Tarea 1: Generación de claves  Generamos las claves:  alejandrogv@AlejandroGV:~$ gpg --gen-key gpg (GnuPG) 2.2.27; Copyright (C) 2021 Free Software Foundation, Inc. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Nota: Usa &amp;quot;gpg --full-generate-key&amp;quot; para el diálogo completo de generación de clave. GnuPG debe construir un ID de usuario para identificar su clave. Nombre y apellidos: ALejandro Gutiérrez Valencia Dirección de correo electrónico: tojandro@gmail.</description>
    </item>
    
    <item>
      <title>Escenario KVM</title>
      <link>https://alepeteporico.github.io/practicas/escenario_kvm/</link>
      <pubDate>Mon, 08 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/escenario_kvm/</guid>
      <description>Definamos nuestra red interna llamada interna_agv en un fichero xml.  &amp;lt;network&amp;gt; &amp;lt;name&amp;gt;interna_agv&amp;lt;/name&amp;gt; &amp;lt;forward mode=&amp;quot;bridge&amp;quot;/&amp;gt; &amp;lt;bridge name=&amp;quot;br0&amp;quot;/&amp;gt; &amp;lt;/network&amp;gt;  Vamos a crear la red.  alejandrogv@AlejandroGV:~/kvm/redes$ virsh -c qemu:///system net-create --file interna_agv.xml La red interna_agv ha sido creada desde interna_agv.xml  Y hacemos lo mismo con la red DMZ.  &amp;lt;network&amp;gt; &amp;lt;name&amp;gt;interna_agv&amp;lt;/name&amp;gt; &amp;lt;forward mode=&amp;quot;bridge&amp;quot;/&amp;gt; &amp;lt;bridge name=&amp;quot;br0&amp;quot;/&amp;gt; &amp;lt;/network&amp;gt; alejandrogv@AlejandroGV:~/kvm/redes$ virsh -c qemu:///system net-create --file dmz.xml La red dmz_agv ha sido creada desde dmz.</description>
    </item>
    
    <item>
      <title>Configuración del escenario router-nat con vagrant y ansible</title>
      <link>https://alepeteporico.github.io/practicas/ejercicio3_vagrant_ansible/</link>
      <pubDate>Sat, 06 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/ejercicio3_vagrant_ansible/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Migración de aplicación web PHP</title>
      <link>https://alepeteporico.github.io/practicas/migracion_durpal/</link>
      <pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/migracion_durpal/</guid>
      <description>Nos daremos de alta en un hosting gratuito, en mi caso cdmon. Y crearemos un nuevo hosting.  Migración de la base de datos.  Lo primero que haremos será restaurar nuestra base de datos en nuestro hosting, para ello entraremos en la pestaña de mysql.   Creamos una nueva base de datos, en mi caso la llamaré joomlaagv.   y accederemos a phpMyAdmin con las credenciales que se nos otorgan.</description>
    </item>
    
    <item>
      <title>Instalación local de un CMS PHP</title>
      <link>https://alepeteporico.github.io/practicas/cmsphp_local/</link>
      <pubDate>Tue, 02 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/cmsphp_local/</guid>
      <description>VagrantFile Vagrant.configure(&amp;quot;2&amp;quot;) do |config| config.vm.define :cmsagv do |cmsagv| cmsagv.vm.box = &amp;quot;debian/bullseye64&amp;quot; cmsagv.vm.hostname = &amp;quot;cmsagv&amp;quot; cmsagv.vm.network &#39;private_network&#39;, :ip =&amp;gt; &#39;192.168.100.200&#39; cmsagv.vm.network :private_network, :libvirt__network_name =&amp;gt; &amp;quot;red1&amp;quot;, :libvirt__dhcp_enabled =&amp;gt; false, :ip =&amp;gt; &amp;quot;172.22.100.5&amp;quot;, :libvirt__forward_mode =&amp;gt; &amp;quot;none&amp;quot; end config.vm.define :backup do |backup| backup.vm.box = &amp;quot;debian/bullseye64&amp;quot; backup.vm.hostname = &amp;quot;backup&amp;quot; backup.vm.network :private_network, :libvirt__network_name =&amp;gt; &amp;quot;red1&amp;quot;, :libvirt__dhcp_enabled =&amp;gt; false, :ip =&amp;gt; &amp;quot;172.22.100.10&amp;quot;, :libvirt__forward_mode =&amp;gt; &amp;quot;none&amp;quot; end end Instalamos un servidor LAMP
Apache Hacemos una instalación sencilla:
vagrant@cmsalegv:~$ sudo apt install apache2 apache2-utils  Y creamos una regla en iptables para permitir la conexión http</description>
    </item>
    
    <item>
      <title>Gestión de paquetería en debian</title>
      <link>https://alepeteporico.github.io/practicas/paqueteria/</link>
      <pubDate>Fri, 01 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/paqueteria/</guid>
      <description>APT, APTITUDE Y DPKG  Que acciones consigo al realizar apt update y apt upgrade. Explica detalladamente.    update: actualiza la lista de paquetes que están disponibles y la versión actual usando los repositorios que se alojan en el fichero sources.list
  upgrade: Esta opción la usaríamos después del update, pues la lista de paquetes y sus versiones estaría actualizada y este comando instalaría estas nuevas versiones</description>
    </item>
    
    <item>
      <title>Implantación y despliegue de una aplicación web estática 2021</title>
      <link>https://alepeteporico.github.io/practicas/web_estatica/</link>
      <pubDate>Wed, 29 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/web_estatica/</guid>
      <description>Vamos a realizar e implementar una aplicación web estática, para ello usaremos el generador de páginas estáticas jekyll y usaremos para implementarlo surge. jekyll  Para la instalación de jekyll primero debemos asegurarnos de tener instalado ruby y algunas dependencias ya que la aplicación está escrita en este lenguaje.  sudo apt install ruby ruby-dev  Y ahora si podemos instalar jekyll.  sudo gem install bundler jekyll  Ahora crearemos nuestro sitio web en el entorno de desarrollo  jekyll new jekyll_dinamico  Vamos a visualizar el contenido de este sitio que se nos ha generado por defecto.</description>
    </item>
    
    <item>
      <title>Herramientas de seguridad</title>
      <link>https://alepeteporico.github.io/practicas/herramientas_de_seguridad/</link>
      <pubDate>Thu, 23 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/herramientas_de_seguridad/</guid>
      <description>Sistemas de detección de intrusos  Vamos a usar como sistema de detección de intrusos la herramienta SURICATA, parece ser la más usada a día de hoy   Vamos a instalar el paquete de suricata y oinkmaster que usaremos mas adelante.  root@suricata:~# apt install suricata  La instalación ha sido sencilla, para configurar los parametros básicos iremos al fichero /etc/suricata/suricata.yaml, lo primero que haremos será asegurarnos que suricata escucha por la interfaz correcta.</description>
    </item>
    
    <item>
      <title>Instalación y configuración de un servidor PXE en debian</title>
      <link>https://alepeteporico.github.io/practicas/pxe/</link>
      <pubDate>Tue, 21 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/pxe/</guid>
      <description>En la máquina que usaremos como servidor pxe debemos instalar también un servidor dhcp que dará direccionamiento IP a nuestros clientes.
 vagrant@pxe:~$ sudo apt install isc-dhcp-server    Ahora en el fichero /etc/dhcp/dhcpd.conf añadimos la configuración de nuestro dhcp.
  option domain-name «servidorpxe.com»; option domain-name-servers «server1.servidorpxe.com»; subnet 192.168.1.100 netmask 255.255.255.0 { range 192.168.1.10 192.168.1.30; option routers 192.168.1.1; option broadcast-address 192.168.1.255; } default-lease-time 600; max-lease-time 7200 authoritative;  Vamos a instalar los paquetes necesarios para nuestro servidor pxe  vagrant@pxe:~$ sudo apt install apache2 tftpd-hpa inetutils-inetd  Ahora añadimos al fichero /etc/default/tftpd-hpa las siguientes líneas para iniciar el demonio.</description>
    </item>
    
    <item>
      <title>Compilación de un kérnel linux a medida</title>
      <link>https://alepeteporico.github.io/practicas/kernel/</link>
      <pubDate>Fri, 17 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/kernel/</guid>
      <description>Vamos a necesitar instalar cierta paquetería como vemos a continuación.
 alejandrogv@AlejandroGV:~/Escritorio/ASIR/sistemas/kernel$ sudo apt install build-essential qtbase5-dev    Necesitamos saber que versión del kernel estamos usando.
 alejandrogv@AlejandroGV:~/Escritorio/ASIR/sistemas/kernel$ uname -r 5.10.0-8-amd64    Descargaremos la versión de nuestro kernel desde la página oficial
 alejandrogv@AlejandroGV:~/Escritorio/ASIR/sistemas/kernel$ wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.10.tar.gz alejandrogv@AlejandroGV:~/Escritorio/ASIR/sistemas/kernel$ ls linux-5.10.tar.gz    Descomprimos este archivo y el resultado será una carpeta con muchisima información.</description>
    </item>
    
    <item>
      <title>Actualización de Debian 10 a Debian 11</title>
      <link>https://alepeteporico.github.io/practicas/actualizacion_debian11/</link>
      <pubDate>Thu, 16 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/actualizacion_debian11/</guid>
      <description>Actualización   Primero debemos actualizar nuestro debian 10 como tenemos por costumbre hacerlo.
 alejandrogv@AlejandroGV:~$ sudo apt update alejandrogv@AlejandroGV:~$ sudo apt upgrade    Es necesario instalar el paquete gcc-8-base aunque es probable que ya lo tengamos pero nos aseguramos.
 alejandrogv@AlejandroGV:~$ sudo apt install gcc-8-base    Ahora editamos nuestro etc/apt/sources.list para añadir los repositorios del nuevo debian &amp;ldquo;bullseye&amp;rdquo;
 deb http://deb.debian.org/debian/ bullseye main contrib non-free # deb-src http://deb.</description>
    </item>
    
    <item>
      <title>Instalación de debian 11 con LVM</title>
      <link>https://alepeteporico.github.io/practicas/instalacion_debian11/</link>
      <pubDate>Thu, 16 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/instalacion_debian11/</guid>
      <description>Empezamos la instalación y seguimos todos los pasos normalmente hasta llegar a la configuración de los discos, la haremos manualmente y en mi caso he creado una máquina virtual para simular lo que hice en mi máquina anfitriona, para ello he creado una partición sin usar simulando que tengo en ella una partición con Windows 10.   Seguidamente elegiremos la opción de &amp;ldquo;Configurar el gestor de volúmenes lógicos&amp;rdquo; y crearemos un grupo de volúmenes.</description>
    </item>
    
    <item>
      <title>COPIAS DE SEGURIDAD Y RECUPERACIÓN</title>
      <link>https://alepeteporico.github.io/practicas/copiasbbdd/</link>
      <pubDate>Mon, 07 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/copiasbbdd/</guid>
      <description>Primero crearemos el directorio donde almacenaremos las copias.
 SQL&amp;gt; CREATE directory COPIA as &#39;/home/backups/&#39;; Directory created.    Comprobemos que se ha creado correctamente.
 SQL&amp;gt; select directory_name from dba_directories; DIRECTORY_NAME -------------------------------------------------------------------------------- COPIA SDO_DIR_WORK SDO_DIR_ADMIN XMLDIR XSDDIR OPATCH_INST_DIR ORACLE_OCM_CONFIG_DIR2 ORACLE_BASE ORACLE_HOME ORACLE_OCM_CONFIG_DIR DATA_PUMP_DIR DIRECTORY_NAME -------------------------------------------------------------------------------- OPATCH_SCRIPT_DIR OPATCH_LOG_DIR JAVA$JOX$CUJS$DIRECTORY$ 14 rows selected.     expdp ale/ale dumpfile=copia_oracle_export_%U.dmp logfile=copia_oracle_export.log directory=CARPETA_EXPORT full=y filesize=100M</description>
    </item>
    
    <item>
      <title>Cortafuegos - OpenStack</title>
      <link>https://alepeteporico.github.io/practicas/cortafuegos_antiguo/</link>
      <pubDate>Mon, 07 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/cortafuegos_antiguo/</guid>
      <description>Nuestro primer paso será instalar nftables.
 debian@dulcinea:~$ sudo apt install nftables    Activamos y habilitamos este servicio.
 debian@dulcinea:~$ sudo systemctl start nftables debian@dulcinea:~$ sudo systemctl enable nftables    Configuraremos la política por defecto a DROP.
 nft chain inet filter input { policy drop \; } nft chain inet filter forward { policy drop \; } nft chain inet filter output { policy drop \; }    Añadimos las reglas de NAT.</description>
    </item>
    
    <item>
      <title>Implantación de aplicaciones web PHP en docker</title>
      <link>https://alepeteporico.github.io/practicas/php_docker/</link>
      <pubDate>Mon, 07 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/php_docker/</guid>
      <description>Vamos a clonar el repositorio necesario para la aplicación.
 alejandrogv@AlejandroGV:~/docker/php$ git clone https://github.com/evilnapsis/bookmedik.git    Crearemos un repositorio con la siguiente estructura.
 alejandrogv@AlejandroGV:~/docker/php/php_docker$ tree . ├── build │ ├── bookmedik │ ├── Dockerfile │ └── script.sh ├── deploy │ └── docker-compose.yml └── README.md    En el fichero docker-compose añadimos lo siguiente.
 version: &amp;quot;3.1&amp;quot; services: db: container_name: mysql image: mariadb restart: always environment: MYSQL_DATABASE: bookmedik MYSQL_USER: bookmedik MYSQL_PASSWORD: admin MYSQL_ROOT_PASSWORD: admin volumes: - /opt/mysql_wp:/var/lib/mysql    Y en la carpeta build crearemos un fichero Dockerfile que rellenaremos de la siguiente forma.</description>
    </item>
    
    <item>
      <title>Proxy, proxy inverso y balanceadores de carga</title>
      <link>https://alepeteporico.github.io/practicas/proxy/</link>
      <pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/proxy/</guid>
      <description>Primero usaremos squid para instalar un proxy.
 vagrant@proxy:~$ sudo apt install squid    Modificamos el fichero /etc/squid/squid.conf para definir las direcciones y puertos que permitiremos y el puerto de funcionamiento.
 acl localnet src 10.0.0.0/24 acl localnet src 172.22.100.0/24 acl SSL_ports port 443 acl Safe_ports port 80 # http acl Safe_ports port 21 # ftp acl Safe_ports port 443 # https acl CONNECT method CONNECT # Deny requests to certain unsafe ports http_access deny !</description>
    </item>
    
    <item>
      <title>Aumento de rendimiento de servidores web von Varnish</title>
      <link>https://alepeteporico.github.io/practicas/rendimientoweb/</link>
      <pubDate>Sat, 05 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/rendimientoweb/</guid>
      <description>Instalamos ansible
 alejandrogv@AlejandroGV:~$ sudo apt install ansible    Ahora clonaremos el repositorio correspondiente con la receta.
 alejandrogv@AlejandroGV:~$ git clone https://github.com/josedom24/ansible_nginx_fpm_php.git    En el interior del respositorio editaremos el fichero hosts añadiendo la dirección de la máquina que usaremos para las pruebas.
 [servidores_web] nodo1 ansible_ssh_host=172.22.100.15 ansible_python_interpreter=/usr/bin/python3    Ejecutamos la funcionalidad playbook de ansible para que se realicen las modificaciones necesarias que usaremos en la máquina de prueba.</description>
    </item>
    
    <item>
      <title>Introducción a la integración continua </title>
      <link>https://alepeteporico.github.io/practicas/ic/</link>
      <pubDate>Fri, 04 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/ic/</guid>
      <description>Integración continúa de aplicación django   Ya tenemos nuestra aplicación y el entorno virtual de la práctica de Despliegue de una aplicación python usaremos la misma, y realizaremos los test.
 (django) alejandrogv@AlejandroGV:~/Escritorio/ASIR/IWEB/despliegue_python/django_tutorial$ python3 manage.py test Creating test database for alias &#39;default&#39;... System check identified no issues (0 silenced). .......... ---------------------------------------------------------------------- Ran 10 tests in 0.056s OK Destroying test database for alias &#39;default&#39;...    Vamos a modificar el fichero polls/templates/polls/index.</description>
    </item>
    
    <item>
      <title>Auditoria</title>
      <link>https://alepeteporico.github.io/practicas/auditoria/</link>
      <pubDate>Mon, 31 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/auditoria/</guid>
      <description>Activa desde SQL*Plus la auditoría de los intentos de acceso fallidos al sistema. Comprueba su funcionamiento.   Primero vamos a visualizar los diferentes parametros de auditorias de los que disponemos.
 SQL&amp;gt; SHOW PARAMETER AUDIT NAME	TYPE	VALUE ------------------------------------ ----------- ------------------------------ audit_file_dest string	/opt/oracle/admin/ORCLCDB/adum p audit_sys_operations	boolean	TRUE audit_syslog_level	string audit_trail	string	DB unified_audit_common_systemlog	string unified_audit_sga_queue_size	integer	1048576 unified_audit_systemlog string    Nosotros usaremos audit_trail
 SQL&amp;gt; ALTER SYSTEM SET audit_trail=db scope=spfile; System altered.</description>
    </item>
    
    <item>
      <title>LDAP</title>
      <link>https://alepeteporico.github.io/practicas/ldap_openstack/</link>
      <pubDate>Mon, 31 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/ldap_openstack/</guid>
      <description>Para esta práctica vamos a usar las claves y certificados que generamos en la práctica de seguridad de https
 [root@quijote ~]# scp /etc/ssl/certs/gonzalonazareno.crt debian@10.0.1.9 [root@quijote ~]# scp /etc/ssl/certs/openstack.crt debian@10.0.1.9 [root@quijote ~]# scp /etc/ssl/private/openstack.key debian@10.0.1.9    Vamos a mover estos certificados a un sitio apropiado.
 debian@freston:~$ sudo mv gonzalonazareno.crt /etc/ssl/certs/ debian@freston:~$ sudo mv openstack.crt /etc/ssl/certs/ debian@freston:~$ sudo mv openstack.key /etc/ssl/private/    Vamos a crear unas acl para que el usuario openldap que es el encargado de ejecutar los servicios de sldap tenga permisos sobre estos certificados.</description>
    </item>
    
    <item>
      <title>Servidor nginx</title>
      <link>https://alepeteporico.github.io/practicas/nginx/</link>
      <pubDate>Mon, 31 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/nginx/</guid>
      <description>Crea una máquina del cloud con una red pública. Añade la clave pública del profesor a la máquina. Instala el servidor web nginx en la máquina. Modifica la página index.html que viene por defecto y accede a ella desde un navegador.   La IP del servidor es la 172.22.201.5
  Una vez añadida la clave pública del profesor instalamos el servidor web nginx.
 debian@nginx:~$ sudo apt install nginx    Comprobamos que podemos acceder perfectamente desde fuera.</description>
    </item>
    
    <item>
      <title>Despliegue de un cluster de kubernetes</title>
      <link>https://alepeteporico.github.io/practicas/cluster_kubernetes/</link>
      <pubDate>Thu, 27 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/cluster_kubernetes/</guid>
      <description>Crearemos 3 máquinas Vagrant que nos servirán, una de controlador y las otras dos de workers.
  En la máquina que usaremos como controlador descargaremos e instalaremos usando curl el script que instalará el servicio de k3.
 root@servidor:/usr/local/bin# curl -sfL https://get.k3s.io | sh -    Podemos comprobar mediante netstat que se ha abierto un puerto 6443 que es el que usa k3s por defecto.</description>
    </item>
    
    <item>
      <title>OpenStack: Configuración HTTPS</title>
      <link>https://alepeteporico.github.io/practicas/https_openstack/</link>
      <pubDate>Thu, 27 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/https_openstack/</guid>
      <description>El siguiente paso de nuestro proyecto es configurar de forma adecuada el protocolo HTTPS en nuestro servidor web para nuestra aplicaciones web. Para ello vamos a emitir un certificado wildcard en la AC Gonzalo Nazareno utilizando para la petición la utilidad &amp;ldquo;gestiona&amp;rdquo;.   Lo primero que debemos hacer para llevarlo a cabo es dirigirnos a centos donde crearemos los directorios nesarios y crearemos una clave RSA.
 [centos@quijote ~]$ sudo mkdir /etc/ssl/private [centos@quijote ~]$ sudo chmod 700 /etc/ssl/private Generating RSA private key, 4096 bit long modulus (2 primes) .</description>
    </item>
    
    <item>
      <title>Instalación y configuración de LDAP</title>
      <link>https://alepeteporico.github.io/practicas/ldap/</link>
      <pubDate>Sat, 15 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/ldap/</guid>
      <description>LDAP es un protocolo de tipo cliente-servidor para acceder a un servicio de directorio. Un directorio es como una base de datos, pero en general contiene información más descriptiva y más basada en atributos.
  Lo primero que debemos hacer es verificar nuestro FQDN (Fully Qualified Domain Name) que usaremos mas tarde para la configuración.
 debian@freston:~$ hostname -f freston.alegv.gonzalonazareno.org    Instalaremos el paquete de LDAP
 debian@freston:~$ sudo apt install slapd    Durante esta instalación tendremos que introducir una contraseña para el administrador.</description>
    </item>
    
    <item>
      <title>Almacenamiento</title>
      <link>https://alepeteporico.github.io/practicas/almacenamiento_bbdd/</link>
      <pubDate>Mon, 10 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/almacenamiento_bbdd/</guid>
      <description>Muestra los objetos a los que pertenecen las extensiones del tablespace TS2 (creado por tí) y el tamaño de cada una de ellas. Tendrás que crear objetos en él previamente, claro.   Vamos a crear este Tablespace.
 SQL&amp;gt; CREATE TABLESPACE TS2 2 DATAFILE &#39;/home/oracle/ts2.dbf&#39; 3 SIZE 200K 4 AUTOEXTEND ON 5 DEFAULT STORAGE ( 6 INITIAL 200K 7 NEXT 200K 8 MAXEXTENTS 3 9 PCTINCREASE 100); Tablespace created.    Vamos a crear una prueba para ver como funciona y añadamos contenido a ver como funciona.</description>
    </item>
    
    <item>
      <title>Servidor DNS</title>
      <link>https://alepeteporico.github.io/practicas/dns/</link>
      <pubDate>Mon, 10 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/dns/</guid>
      <description>En nuestra red local tenemos un servidor Web que sirve dos páginas web: www.iesgn.org, departamentos.iesgn.org
  Vamos a instalar en nuestra red local un servidor DNS (lo puedes instalar en el mismo equipo que tiene el servidor web)
  Voy a suponer en este documento que el nombre del servidor DNS va a ser pandora.iesgn.org. El nombre del servidor de tu prácticas será tunombre.iesgn.org.
   DNSmasq Instala el servidor dns dnsmasq en pandora.</description>
    </item>
    
    <item>
      <title>Instalación de servidores y clientes</title>
      <link>https://alepeteporico.github.io/practicas/serv_client/</link>
      <pubDate>Mon, 05 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/serv_client/</guid>
      <description>Tras la instalación de cada servidor, debe crearse una base de datos con al menos tres tablas o colecciones y poblarse de datos adecuadamente. Debe crearse un usuario y dotarlo de los privilegios necesarios para acceder remotamente a los datos. Se proporcionará esta información al resto de los miembros del grupo.
 Los clientes deben estar siempre en máquinas diferentes de los respectivos servidores a los que acceden. Se documentará todo el proceso de configuración de los servidores.</description>
    </item>
    
    <item>
      <title>Práctica de PLSQL</title>
      <link>https://alepeteporico.github.io/practicas/practica_plsql/</link>
      <pubDate>Mon, 29 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/practica_plsql/</guid>
      <description> Realiza una función que reciba el código de un aerogenerador y una fecha y devuelva el total de energía producida en esa fecha. Debes controlar las siguientes excepciones: Aerogenerador inexistente y Aerogenerador en desconexión durante ese día.  create or replace function EnergiaDiaria (v_codigo AEROGENERADORES.CODIGO%type, v_fecha) </description>
    </item>
    
    <item>
      <title>Práctica mdadm y rclone</title>
      <link>https://alepeteporico.github.io/practicas/mdadm_rclone/</link>
      <pubDate>Wed, 17 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/mdadm_rclone/</guid>
      <description>RAID 5 Fichero VagrantFile:  # -*- mode: ruby -*- # vi: set ft=ruby : Vagrant.configure(&amp;quot;2&amp;quot;) do |config| config.vm.box = &amp;quot;debian/buster64&amp;quot; config.vm.hostname = &amp;quot;practica1&amp;quot; config.vm.provider :virtualbox do |v| disco = &#39;.vagrant/disco.vdi&#39; v.customize [&amp;quot;createhd&amp;quot;,&amp;quot;--filename&amp;quot;,disco,&amp;quot;--size&amp;quot;, 1024] v.customize [&amp;quot;storageattach&amp;quot;,:id,&amp;quot;--storagectl&amp;quot;,&amp;quot;SATA Controller&amp;quot;,&amp;quot;--port&amp;quot;,1,&amp;quot;--device&amp;quot;,0,&amp;quot;--type&amp;quot;,&amp;quot;hdd&amp;quot;,&amp;quot;--medium&amp;quot;,disco] disco2 = &#39;.vagrant/disco2.vdi&#39; v.customize [&amp;quot;createhd&amp;quot;,&amp;quot;--filename&amp;quot;,disco2,&amp;quot;--size&amp;quot;, 1024] v.customize [&amp;quot;storageattach&amp;quot;,:id,&amp;quot;--storagectl&amp;quot;,&amp;quot;SATA Controller&amp;quot;,&amp;quot;--port&amp;quot;,2,&amp;quot;--device&amp;quot;,0,&amp;quot;--type&amp;quot;,&amp;quot;hdd&amp;quot;,&amp;quot;--medium&amp;quot;,disco2] disco3 = &#39;.vagrant/disco3.vdi&#39; v.customize [&amp;quot;createhd&amp;quot;,&amp;quot;--filename&amp;quot;,disco3,&amp;quot;--size&amp;quot;, 1024] v.customize [&amp;quot;storageattach&amp;quot;,:id,&amp;quot;--storagectl&amp;quot;,&amp;quot;SATA Controller&amp;quot;,&amp;quot;--port&amp;quot;,3,&amp;quot;--device&amp;quot;,0,&amp;quot;--type&amp;quot;,&amp;quot;hdd&amp;quot;,&amp;quot;--medium&amp;quot;,disco3] disco4 = &#39;.vagrant/disco4.vdi&#39; v.customize [&amp;quot;createhd&amp;quot;,&amp;quot;--filename&amp;quot;,disco4,&amp;quot;--size&amp;quot;, 1024] v.customize [&amp;quot;storageattach&amp;quot;,:id,&amp;quot;--storagectl&amp;quot;,&amp;quot;SATA Controller&amp;quot;,&amp;quot;--port&amp;quot;,4,&amp;quot;--device&amp;quot;,0,&amp;quot;--type&amp;quot;,&amp;quot;hdd&amp;quot;,&amp;quot;--medium&amp;quot;,disco4] disco5 = &#39;.vagrant/disco5.vdi&#39; v.customize [&amp;quot;createhd&amp;quot;,&amp;quot;--filename&amp;quot;,disco5,&amp;quot;--size&amp;quot;, 1024] v.</description>
    </item>
    
    <item>
      <title>Configuración del escenario en OpenStack</title>
      <link>https://alepeteporico.github.io/practicas/escenearioos/</link>
      <pubDate>Tue, 16 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/escenearioos/</guid>
      <description>El escenario que debemos montar es el siguiente:
Nosotros tenemos nuestra propia red, pero debemos crear dos nuevas para el escenario y añadir las redes conrrespondientes a sus máquinas
Nuestro siguiente paso será deshabilitar los puertos de Dulcinea que será la máquina que usaremos para conectarnos a las demás y salir al exterior Para este proposito usaremos OpenStack Client alejandrogv@AlejandroGV:~$ source Escritorio/ASIR/hlc/openstackclient/bin/activate source ~/Descargas/Proyecto\ de\ a.gutierrez-openrc.sh
Ahora listaremos las interfaces que tenemos en nuestro proyecto</description>
    </item>
    
    <item>
      <title>Servidor DHCP</title>
      <link>https://alepeteporico.github.io/practicas/dhcp/</link>
      <pubDate>Tue, 16 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/dhcp/</guid>
      <description>Lee el documento Teoría: Servidor DHCP y explica el funcionamiento del servidor DHCP resumido en este gráfico.  En primer lugar el cliente manda una petición DHCPDISCOVER en cuanto se inicia, ya que no tiene configuración de IP usa esta petición para ver si hay un servidor DHCP que pueda darle una dirección.
Después de esto el cliente esperará en estado SELECTING y recibirá las ofertas DHCPOFFER del servidor o servidores DHCP que pueda haber en nuestra red local.</description>
    </item>
    
    <item>
      <title>Actualización de CentOS 7 a CentOS 8</title>
      <link>https://alepeteporico.github.io/practicas/centos8/</link>
      <pubDate>Fri, 19 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/centos8/</guid>
      <description>Antes de comenzar debemos instalar si no las tenemos ya las siguientes herramientas:
 [centos@quijote ~]$ sudo yum install epel-release -y [centos@quijote ~]$ sudo yum install yum-utils -y [centos@quijote ~]$ sudo yum install rpmconf -y  Ahora usaremos rpmconf para verificar conflictos en ficheros de configuración:
 [centos@quijote ~]$ sudo rpmconf -a  Limpiamos los paquetes innecesarios:
 [centos@quijote ~]$ sudo package-cleanup --leaves [centos@quijote ~]$ sudo package-cleanup --orphans  Instalamos el nuevo gestor de paquetes que usa CentOS 8, dnf:</description>
    </item>
    
    <item>
      <title>Implantanción y despliegue de una web estática</title>
      <link>https://alepeteporico.github.io/practicas/pagina_est%C3%A1tica/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/pagina_est%C3%A1tica/</guid>
      <description>La instalación es tan sencilla como usar apt:
sudo apt install hugo  Una vez instalado el siguiente paso sería crear un sitio web:
hugo new site [nombre]  Esto creará una carpeta donde podremos configurar nuestra página, para ello primero descargaremos desde la página oficial de hugo un tema. Debemos fijarnos que se corresponde con nuestra versión de hugo o es inferior, si elegimos una plantilla que necesite una versión de hugo superior dará problemas.</description>
    </item>
    
    <item>
      <title>Servidor LEMP</title>
      <link>https://alepeteporico.github.io/practicas/lemp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/lemp/</guid>
      <description>Vamos a instalar todos los paquetes necesarios.  debian@mrrobot:~$ sudo apt install nginx mariadb-client mariadb-server php php-mysql php-fpm  También debemos instalar el servidor de aplicaciones php-fpm.  debian@mrrobot:~$ sudo apt install php7.4-fpm php7.4 Virtualhosting  Crearemos un virtual host en sites-available  server { listen 80; listen [::]:80; root /var/www/web; index index.html index.htm index.nginx-debian.html; server_name www.alejandrogv.site; location / { try_files $uri $uri/ =404; } }  Para que nuestro virtualhost por defecto sea este, debemos añadir la siguiente línea el el fichero default de el directorio sites-available, dentro del bloque server.</description>
    </item>
    
  </channel>
</rss>
