<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Alepetepórico Blog</title>
    <link>https://alepeteporico.github.io/</link>
    <description>Recent content on Alepetepórico Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 16 Feb 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://alepeteporico.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Auditorias de bases de datos</title>
      <link>https://alepeteporico.github.io/practicas/auditoria/</link>
      <pubDate>Thu, 16 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/auditoria/</guid>
      <description>Activa desde SQL*Plus la auditoría de los intentos de acceso exitosos al sistema. Comprueba su funcionamiento.   Vamos a activarlo.  SQL&amp;gt; ALTER SYSTEM SET audit_trail=db scope=spfile; System altered.  Reiniciamos la base de datos para comprobar.  SQL&amp;gt; shutdown Database closed. Database dismounted. ORACLE instance shut down. SQL&amp;gt; startup ORACLE instance started. Total System Global Area 1660941680 bytes Fixed Size	9135472 bytes Variable Size	973078528 bytes Database Buffers	671088640 bytes Redo Buffers	7639040 bytes Database mounted.</description>
    </item>
    
    <item>
      <title>Almacenamiento 2023</title>
      <link>https://alepeteporico.github.io/practicas/almacenamiento2023/</link>
      <pubDate>Wed, 25 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/almacenamiento2023/</guid>
      <description>ORACLE  Establece que los objetos que se creen en el TS1 (creado por Alumno 1) tengan un tamaño inicial de 200K, y que cada extensión sea del doble del tamaño que la anterior. El número máximo de extensiones debe ser de 3.   Primero apagamos este tablespace para poder modificarlo.  SQL&amp;gt; ALTER TABLESPACE TS1 OFFLINE; Tablespace altered.  Alteramos el tablespace tal y como se nos pide.  ALTER TABLESPACE TS1 DEFAULT STORAGE ( INITIAL 200K MAXEXTENTS 3 PCTINCREASE 200);  Sin embargo, esto nos da un error ORA-25143: default storage clause is not compatible with allocation policy creía que el problema estaba en que la segmentación se crea de forma automatica, y trate de cambiarla a manual sin ningún resultado, por ello he eliminiado el tablespace y lo he creado de 0 con estos nuevos parametros.</description>
    </item>
    
    <item>
      <title>Almacenamiento en BBDD</title>
      <link>https://alepeteporico.github.io/apuntes/almacenamiento_bbdd/</link>
      <pubDate>Wed, 25 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/apuntes/almacenamiento_bbdd/</guid>
      <description>TABLESPACES   Es una especie de carpeta que contiene las tablas, indices, etc&amp;hellip; que corresponde a uno o variows datafiles.
  (No mezclar datos de distinta naturaleza en el mismo tablespace).
  Importantes en la administración por el punto de que se puede activar o desactivar:
  ALTER TABLESPACE X OFFLINE; ALTER TABLESPACE X ONLINE;    </description>
    </item>
    
    <item>
      <title>Gestion de Usuarios BBDD</title>
      <link>https://alepeteporico.github.io/practicas/usuario2023/</link>
      <pubDate>Wed, 04 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/usuario2023/</guid>
      <description>Parte Individual: MongoDB  Averigua si existe la posibilidad en MongoDB de limitar el acceso de un usuario a los datos de una colección determinada.   Al crear un usuario podemos especificar la colección que queremos que pueda acceder y los permisos que le damos sobre ella, como solo lectura o lectura y escritura&amp;hellip; Para ello entramos con el usuario administrador, entramos en la base de datos sobre la que queremos darle privilegios y creamos este usuario.</description>
    </item>
    
    <item>
      <title>Pequeño ejercicio plsql</title>
      <link>https://alepeteporico.github.io/practicas/plsql_peque%C3%B1o/</link>
      <pubDate>Sat, 03 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/plsql_peque%C3%B1o/</guid>
      <description>Hacer un procedimiento que muestre el nombre y el salario del empleado cuyo código es 7082.  CREATE OR REPLACE PROCEDURE cod_7082 IS vnombre emp.ename%TYPE; vsal emp.sal%TYPE; BEGIN SELECT ename, sal INTO vnombre, vsal FROM EMP WHERE EMPNO=&#39;7082&#39;; dbms_output.put_line(&#39;El empleado: &#39;||vnombre||&#39;, gana: &#39;||vsal); END cod_7082; SQL&amp;gt; exec cod_7082; El empleado: ALEJANDRO, gana: 2050 PL/SQL procedure successfully completed. Hacer un procedimiento que reciba como parámetro un código de empleado y devuelva su nombre  CREATE OR REPLACE PROCEDURE cod_nombre (cod_emp emp.</description>
    </item>
    
    <item>
      <title>practica grupal plsql</title>
      <link>https://alepeteporico.github.io/practicas/plsql_grupo/</link>
      <pubDate>Sat, 03 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/plsql_grupo/</guid>
      <description>Realiza una función ComprobarPago que reciba como parámetros un código de cliente y un código de actividad y devuelva un TRUE si el cliente ha pagado la última actividad con ese código que ha realizado y un FALSE en caso contrario. Debes controlar las siguientes excepciones: Cliente inexistente, Actividad Inexistente, Actividad realizada en régimen de Todo Incluido y El cliente nunca ha realizado esa actividad.  CREATE OR REPLACE PROCEDURE ClienteInexistente (v_codcliente personas.</description>
    </item>
    
    <item>
      <title>Interconexion 2023</title>
      <link>https://alepeteporico.github.io/practicas/interconexion2023/</link>
      <pubDate>Tue, 15 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/interconexion2023/</guid>
      <description>Conexión de Oracle a Oracle  Debemos configurar el fichero tnsnames.ora y añadir la segunda base de datos que está en otra máquina, para ello añadiremos el siguiete contenido al fichero.  ORACLE2 = (DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.121.41)(PORT = 1521)) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = ORCLCDB) ) )  Comprobamos que tenemos conexión a la segunda base de datos.  root@oracleagv:~# tnsping ORACLE2 TNS Ping Utility for Linux: Version 19.</description>
    </item>
    
    <item>
      <title>Ejercicios de Anisble con vagrant</title>
      <link>https://alepeteporico.github.io/ejercicios/ejercicios_ansibld/</link>
      <pubDate>Sat, 18 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/ejercicios/ejercicios_ansibld/</guid>
      <description>Ejercicio 1   repositorio del ansible
  Salida de la ejecución del playbook.
  alejandrogv@AlejandroGV:~/vagrant/servicios/ejercicios_ansible/ejercicio1$ ansible-playbook site.yaml [WARNING]: Found both group and host with same name: ejercicio1 PLAY [ejercicio1] *************************************************************************************** TASK [Gathering Facts] ********************************************************************************** ok: [ejercicio1] TASK [Crear usuario alejandro] ************************************************************************** ok: [ejercicio1] TASK [Descarga latest.zip] ****************************************************************************** ok: [ejercicio1] TASK [Actualización] ************************************************************************************ ok: [ejercicio1] TASK [Instala los paquetes necesarios] ****************************************************************** ok: [ejercicio1] TASK [Descomprime latest.zip] *************************************************************************** ok: [ejercicio1] TASK [Crear una base de datos] ************************************************************************** ok: [ejercicio1] TASK [Crear usuario de la bd] *************************************************************************** changed: [ejercicio1] TASK [Clonar repositorio github] ************************************************************************ changed: [ejercicio1] PLAY RECAP ********************************************************************************************** ejercicio1 : ok=9 changed=2 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0 Ejercicio 2  Vagrantfile del escenario  Vagrant.</description>
    </item>
    
    <item>
      <title>Kubernetes</title>
      <link>https://alepeteporico.github.io/practicas/kubernetes/</link>
      <pubDate>Sat, 11 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/kubernetes/</guid>
      <description>Vamos a instalar la aplicación de bookmedik que instalamos con docker en una prática anterior, esta vez con kubernetes.  Despliegue en minikube  Salida de los comando que nos posibilitan ver los recursos que has creado en el cluster.  alejandrogv@AlejandroGV:~/kubernetes/bookmedik_kubernetes/minikube$ kubectl get pv,pvc NAME CAPACITY ACCESS MODES RECLAIM POLICY STATUS CLAIM STORAGECLASS REASON AGE persistentvolume/pvc-2b917463-3f4b-4da5-af30-f159dfd61c14 3Gi RWO Delete Bound default/pvc-bookmedik standard 40s NAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE persistentvolumeclaim/pvc-bookmedik Bound pvc-2b917463-3f4b-4da5-af30-f159dfd61c14 3Gi RWO standard 42s alejandrogv@AlejandroGV:~/kubernetes/bookmedik_kubernetes/minikube$ kubectl get all NAME READY STATUS RESTARTS AGE pod/bookmedik-5f8c5f6bd7-5rrqc 1/1 Running 0 2m24s pod/bookmedik-5f8c5f6bd7-l85nv 1/1 Running 0 2m24s pod/mariadb-7cd5675f98-xv8xc 1/1 Running 0 2m23s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/bookmedik NodePort 10.</description>
    </item>
    
    <item>
      <title>Implantación de aplicaciones web Python en docker</title>
      <link>https://alepeteporico.github.io/practicas/docker_python/</link>
      <pubDate>Fri, 10 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/docker_python/</guid>
      <description>Puntos a tener el cuenta.   La aplicación debe guardar los datos en una base de datos mariadb.
  La aplicación se podrá configurar para indicar los parámetros de conexión a la base de datos: usuario, contraseña, host y base de datos.
  La aplicación deberá tener creado un usuario administrador para el acceso.
  Aplicación Crea una imagen docker para poder desplegar un contenedor con la aplicación.</description>
    </item>
    
    <item>
      <title>Servidor de correos</title>
      <link>https://alepeteporico.github.io/practicas/correo_vps/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/correo_vps/</guid>
      <description>Gestión de correos desde el servidor  Añadiremos tres registros a nuestra zona DNS (A, MX y SPF).  Tarea 1  Ahora nos dirigimos a nuestra máquina e instalamos el servicio de postfix.  debian@mrrobot:~$ sudo apt install postfix bsd-mailx  Vamos a enviar un correo y comprobar que lo recibimos.  debian@mrrobot:~$ mail tojandro@gmail.com Subject: prueba Prueba de postfix Cc:  También debemos comprobar el log.  Jun 7 16:35:08 mrrobot postfix/pickup[3394206]: 7E9D0A06E6: uid=1000 from=&amp;lt;debian&amp;gt; Jun 7 16:35:08 mrrobot postfix/cleanup[3394223]: 7E9D0A06E6: message-id=&amp;lt;20220607163508.</description>
    </item>
    
    <item>
      <title>Aumento de rendimiento en servidores web</title>
      <link>https://alepeteporico.github.io/practicas/rendimiento/</link>
      <pubDate>Thu, 02 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/rendimiento/</guid>
      <description>HAProxy: Balanceador de carga  Clonamos el repositorio con el escenario.  git clone https://github.com/josedom24/vagrant_ansible_haproxy.git  Una vez hagamos el vagrant up entramos en cada una de las máquinas para ver las direcciones ip que les ha dado vagrant, entonces entramos en ansible/hosts y añadimos estas direcciones.  [servidor_ha] frontend ansible_ssh_host=192.168.121.30 ansible_ssh_user=vagrant ansible_ssh_private_key_file=../.vagrant/machines/frontend/libvirt/private_key ansible_python_interpreter=/usr/bin/python3 [servidores_web] backend1 ansible_ssh_host=192.168.121.250 ansible_ssh_user=vagrant ansible_ssh_private_key_file=../.vagrant/machines/backend1/libvirt/private_key ansible_python_interpreter=/usr/bin/python3 backend2 ansible_ssh_host=192.168.121.14 ansible_ssh_user=vagrant ansible_ssh_private_key_file=../.vagrant/machines/backend2/libvirt/private_key ansible_python_interpreter=/usr/bin/python3  Pasamos la receta de ansible por el escenario.</description>
    </item>
    
    <item>
      <title>Instalación de un CMS python</title>
      <link>https://alepeteporico.github.io/practicas/python_openstack/</link>
      <pubDate>Thu, 02 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/python_openstack/</guid>
      <description>Vamos a crear el entorno virtual en el cual instalaremos Mezzanine.
 alejandrogv@AlejandroGV:~/entornos/mezzanine$ source despliegue/bin/activate (despliegue) alejandrogv@AlejandroGV:~/entornos/mezzanine$    Ahora instalamos con pip mezzanine y creamos un proyecto.
 (despliegue) alejandrogv@AlejandroGV:~/proyecto$ pip install mezzanine (despliegue) alejandrogv@AlejandroGV:~/proyecto$ mezzanine-project cms    Vamos a modificar uno de los ficheros que se ha generado cms/settings.py para usar la base de datos sqlite ya que estamos en el entorno de pruebas.</description>
    </item>
    
    <item>
      <title>Monotorización con Zabbix</title>
      <link>https://alepeteporico.github.io/practicas/monotorizacion/</link>
      <pubDate>Tue, 31 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/monotorizacion/</guid>
      <description>Servicio   Usaremos un sistema de montorización llamado zabbix. Está diseñado para monitorizar y registrar el estado de varios servicios de red, Servidores, y hardware de red. Puede realizar:
  Chequeos simples que pueden verificar la disponibilidad y el nivel de respuesta de servicios estándar como SMTP o HTTP sin necesidad de instalar ningún software sobre el host monitorizado.
  Monitorizar estadísticas como carga de CPU, utilización de red, espacio en disco, etc.</description>
    </item>
    
    <item>
      <title>DRBD y OCFS2</title>
      <link>https://alepeteporico.github.io/practicas/drb_ocfs2/</link>
      <pubDate>Sun, 29 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/drb_ocfs2/</guid>
      <description>Configura un escenario con dos máquinas. Cada una tiene que tener dos discos adicionales (tamaño 1Gb para que la sincronización sea rápida).  Configura en modo Single-primary el recurso wwwdata.  Primero debemos instalar el paquete necesario para usar DRBD en las dos máquinas.  vagrant@maquina1:~$ sudo apt install drbd-utils  Ahora para crear este recurso lo hacemos creando un fichero en /etc/drbd.d/ al que llamaremos wwwdata.res  resource wwwdata { protocol C; meta-disk internal; device /dev/drbd1; syncer { verify-alg sha1; } net { allow-two-primaries; } on maquina1 { disk /dev/vdb; address 192.</description>
    </item>
    
    <item>
      <title>Poblar un directorio LDAP desde un fichero CSV</title>
      <link>https://alepeteporico.github.io/practicas/ldap_csv/</link>
      <pubDate>Fri, 20 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/ldap_csv/</guid>
      <description>Crear entre todos los alumnos de la clase que vayan a hacer esta tarea un fichero CSV que incluya información personal de cada uno incluyendo los siguientes datos:
  Nombre
  Apellidos
  Dirección de correo electrónico
  Nombre de usuario
  Clave pública ssh
    Otro fichero con la siguiente información de los alumnos:
  Hostname
  IPv4</description>
    </item>
    
    <item>
      <title>Usuarios, Grupos y ACLs en LDAP</title>
      <link>https://alepeteporico.github.io/practicas/ldap_uga/</link>
      <pubDate>Fri, 20 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/ldap_uga/</guid>
      <description>Crea 10 usuarios con los nombres que prefieras en LDAP, esos usuarios deben ser objetos de los tipos posixAccount e inetOrgPerson. Estos usuarios tendrán un atributo userPassword. dn: uid=stark,ou=Usuarios,dc=alexgv,dc=gonzalonazareno,dc=org objectClass: posixAccount objectClass: inetOrgPerson objectClass: top cn: stark gidNumber: 2001 homeDirectory: /home/stark loginShell: /bin/bash sn: stark uid: stark uidNumber: 2001 userPassword: {SSHA}loVCFjl442fnkpIZC05Ht+8OwLsgF0Ua dn: uid=rogers,ou=Usuarios,dc=alexgv,dc=gonzalonazareno,dc=org objectClass: posixAccount objectClass: inetOrgPerson objectClass: top cn: rogers gidNumber: 2002 homeDirectory: /home/rogers loginShell: /bin/bash sn: rogers uid: rogers uidNumber: 2002 userPassword: {SSHA}gLim3ka1uQnZtFCMBoD0+NKmQ88/7f+d dn: uid=banner,ou=Usuarios,dc=alexgv,dc=gonzalonazareno,dc=org objectClass: posixAccount objectClass: inetOrgPerson objectClass: top cn: banner gidNumber: 2003 homeDirectory: /home/banner loginShell: /bin/bash sn: banner uid: banner uidNumber: 2003 userPassword: {SSHA}R28hwHBG+MeisvkGM3qS7q049d8p6QO1 dn: uid=romanof,ou=Usuarios,dc=alexgv,dc=gonzalonazareno,dc=org objectClass: posixAccount objectClass: inetOrgPerson objectClass: top cn: romanof gidNumber: 2004 homeDirectory: /home/romanof loginShell: /bin/bash sn: romanof uid: romanof uidNumber: 2004 userPassword: {SSHA}r4NOljTbgWSfO1r4daswgbBDhlLtwMwd dn: uid=burton,ou=Usuarios,dc=alexgv,dc=gonzalonazareno,dc=org objectClass: posixAccount objectClass: inetOrgPerson objectClass: top cn: burton gidNumber: 2005 homeDirectory: /home/burton loginShell: /bin/bash sn: burton uid: burton uidNumber: 2005 userPassword: {SSHA}n8aeZpDwycwusGlKWl56MuTXARrAWhyM dn: uid=thor,ou=Usuarios,dc=alexgv,dc=gonzalonazareno,dc=org objectClass: posixAccount objectClass: inetOrgPerson objectClass: top cn: thor gidNumber: 2006 homeDirectory: /home/thor loginShell: /bin/bash sn: thor uid: thor uidNumber: 2006 userPassword: {SSHA}m20Ph+8uSwScFHcJ6iVpgimoiKawWuc3 dn: uid=strange,ou=Usuarios,dc=alexgv,dc=gonzalonazareno,dc=org objectClass: posixAccount objectClass: inetOrgPerson objectClass: top cn: strange gidNumber: 2007 homeDirectory: /home/strange loginShell: /bin/bash sn: strange uid: strange uidNumber: 2007 userPassword: {SSHA}UpziawVa6CL9Kk/g7gVzFRQ4MJWBDFKP dn: uid=parker,ou=Usuarios,dc=alexgv,dc=gonzalonazareno,dc=org objectClass: posixAccount objectClass: inetOrgPerson objectClass: top cn: parker gidNumber: 2008 homeDirectory: /home/parker loginShell: /bin/bash sn: parker uid: parker uidNumber: 2008 userPassword: {SSHA}Px8NYV9wWlc/JxmUWaGaBV28KSucLIYt dn: uid=furia,ou=Usuarios,dc=alexgv,dc=gonzalonazareno,dc=org objectClass: posixAccount objectClass: inetOrgPerson objectClass: top cn: furia gidNumber: 2009 homeDirectory: /home/furia loginShell: /bin/bash sn: furia uid: furia uidNumber: 2009 userPassword: {SSHA}8VRwZX4ts0fe8KBT58h3ywzpj+EEShfV dn: uid=maximof,ou=Usuarios,dc=alexgv,dc=gonzalonazareno,dc=org objectClass: posixAccount objectClass: inetOrgPerson objectClass: top cn: maximof gidNumber: 2010 homeDirectory: /home/maximof loginShell: /bin/bash sn: maximof uid: maximof uidNumber: 2010 userPassword: {SSHA}t1Oa8gRUcI6kfJvVfNpNdMeMXs+05l1K  Ejecutamos este fichero.</description>
    </item>
    
    <item>
      <title>LDAP en alta disponibilidad</title>
      <link>https://alepeteporico.github.io/practicas/ldap_ad/</link>
      <pubDate>Tue, 17 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/ldap_ad/</guid>
      <description>Vamos a instalar un servidor LDAP en ares que va a actuar como servidor secundario o de respaldo del servidor LDAP instalado en apolo, para ello habrá que seleccionar un modo de funcionamiento y configurar la sincronización entre ambos directorios, para que los cambios que se realicen en uno de ellos se reflejen en el otro. Metodo usado: LDAP Syncy Replication   Usaremos este metodo ya que podemos adecuarlo a las necesidades de nuestro escenario como queramos debido a las diferentes útilidades que tiene.</description>
    </item>
    
    <item>
      <title>LDAPs</title>
      <link>https://alepeteporico.github.io/practicas/ldaps/</link>
      <pubDate>Tue, 17 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/ldaps/</guid>
      <description>Para usar la configuración segura de ldap primero debemos tener los certificados correspondientes, primero creamos una clave privada con openssl.  root@apolo:~# openssl genrsa 4096 &amp;gt; /etc/ssl/private/apoloalexgv.key  Y usando esa clave creamos un certificado que deberá ser firmado por la unidad certificadora del gonzalo nazareno en nuestro caso.  root@apolo:~# openssl req -new -key /etc/ssl/private/apoloalexgv.key -out /root/apoloalexgv.csr  Con la clave, el certificado firmado y el certificado del gonzalo nazareno que descargaremos de gestiona tendremos todos los certificados necesarios, veamos donde se ubica cada uno.</description>
    </item>
    
    <item>
      <title>Usuarios bases de datos</title>
      <link>https://alepeteporico.github.io/practicas/usuarios/</link>
      <pubDate>Tue, 17 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/usuarios/</guid>
      <description>(ORACLE, Postgres, MySQL) Crea un usuario llamado Becario y, sin usar los roles de ORACLE, dale los siguientes privilegios: Oracle  Conectarse a la base de datos.  GRANT CREATE SESSION TO Becario;  Modificar el número de errores en la introducción de la contraseña de cualquier usuario.  GRANT CREATE PROFILE TO Becario; CREATE PROFILE Limitepasswd LIMIT FAILED_LOGIN_ATTEMPTS 5;  Modificar índices en cualquier esquema (este privilegio podrá pasarlo a quien quiera)   </description>
    </item>
    
    <item>
      <title>Despliegue de CMS java</title>
      <link>https://alepeteporico.github.io/practicas/cms_java/</link>
      <pubDate>Wed, 04 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/cms_java/</guid>
      <description>Hemos elegido la aplicación Guacamole la cual permite administrar de forma remota el sistema donde lo instalemos mediante una interfaz web usando protocolos como: ssh, rdp o vnc.
  Para empezar instalaremos la paquetería necesaria.
  vagrant@cmsjava:~$ sudo apt install build-essential libcairo2-dev libjpeg62-turbo-dev libpng-dev libtool-bin libossp-uuid-dev libavcodec-dev libavformat-dev libswscale-dev freerdp2-dev libpango1.0-dev libssh2-1-dev libtelnet-dev libvncserver-dev libwebsockets-dev libpulse-dev libvorbis-dev libwebp-dev  Descargaremos la aplicación del sitio oficial.  vagrant@cmsjava:~$ wget -O &#39;guacamole-server-1.</description>
    </item>
    
    <item>
      <title>Trabajo con almacenamiento en libvirt</title>
      <link>https://alepeteporico.github.io/ejercicios/almacenamiento_libvirt/</link>
      <pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/ejercicios/almacenamiento_libvirt/</guid>
      <description>Crea un nuevo pool de almacenamiento de tipo lvm, y crea un volumen de 3Gi dentro que sea una volumen lógico. Con virt-install instala una máquina que se llame original_tunombre cuyo disco sea el volumen creado.  &amp;lt;pool type=&#39;logical&#39;&amp;gt; &amp;lt;name&amp;gt;pool_lvm&amp;lt;/name&amp;gt; &amp;lt;capacity unit=&#39;bytes&#39;&amp;gt;5368709120&amp;lt;/capacity&amp;gt; &amp;lt;source&amp;gt; &amp;lt;name&amp;gt;debian&amp;lt;/name&amp;gt; &amp;lt;/source&amp;gt; &amp;lt;target&amp;gt; &amp;lt;path&amp;gt;/home/alejandrogv/libvirt/pool&amp;lt;/path&amp;gt; &amp;lt;permissions&amp;gt; &amp;lt;mode&amp;gt;0711&amp;lt;/mode&amp;gt; &amp;lt;owner&amp;gt;0&amp;lt;/owner&amp;gt; &amp;lt;group&amp;gt;0&amp;lt;/group&amp;gt; &amp;lt;/permissions&amp;gt; &amp;lt;/target&amp;gt; &amp;lt;/pool&amp;gt; virsh -c qemu:///system pool-define --file pool.xml virsh -c qemu:///system pool-start pool_lvm sudo lvcreate -L 3G -n pool1 debian virt-install --connect qemu:///system --network network=default --name=original_alegv --memory 1024 --vcpus 1 --disk /dev/debian/pool1 --cdrom /home/alejandrogv/Escritorio/ISOS/debian-11.</description>
    </item>
    
    <item>
      <title>Trabajo con redes en libvirt</title>
      <link>https://alepeteporico.github.io/ejercicios/redes_libvirt/</link>
      <pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/ejercicios/redes_libvirt/</guid>
      <description>Crea una máquina virtual conectada a la red_interna del ejercicio anterior, utilizando virt-install. Está máquina se debe llamar nodo1_tunombre.  virt-install --connect qemu:///system --cdrom ../Escritorio/ISOS/debian-11.1.0-amd64-netinst.iso --disk size=10 --network network=red_interna --name nodo1_ale --memory 512 --vcpus 1  Crea un clon de la máquina anterior con virt-clone, esta máquina se debe llamar nodo2_tunombre.  virt-clone --original=nodo1_ale --name=nodo2_ale --auto-clone  Crea una red aislada (very isolated) que nos permita unir el nodo1 y el nodo2, pero que no esté conectada al host.</description>
    </item>
    
    <item>
      <title>HTTPS OVH</title>
      <link>https://alepeteporico.github.io/practicas/https_ovh/</link>
      <pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/https_ovh/</guid>
      <description>Explica los pasos fundamentales para la creación del certificado. Especificando los campos que has rellenado en el fichero CSR.  Para este cometido usaremos el servicio letsencrypt, esta unidad certificadora hace use del protocolo ACME que lleva a cabo dos sencillos pasos mediante un agente llamadao certbot los pasos son:   Validación del dominio. Tenemos que demostrar que somos administradores del dominio en el que queremos generar este certificado, esto se puede hacer de dos formas:    Creando un fichero de configuración en una ruta determinada, si la autoridad certificadora puede acceder por el puerto 80 y verificar este fichero y validar las firmas de las claves que se generarían para hacer dicha conexión, entonces verificará que somos administradores del dominio.</description>
    </item>
    
    <item>
      <title>Desplegando aplicaciones flask con apache2 &#43; uwsgi</title>
      <link>https://alepeteporico.github.io/ejercicios/apache_uwsgi/</link>
      <pubDate>Mon, 11 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/ejercicios/apache_uwsgi/</guid>
      <description>Tendremos nuestro entorno virtual donde debemos instalar los siguientes paquetes.  (ejercicio3) alejandrogv@AlejandroGV:~$ pip install flask uwsgi  Clonamos la aplicación que instalaremos.  alejandrogv@AlejandroGV:~/Escritorio/ASIR/IWEB$ git clone https://github.com/josedom24/guestbook.git  En este repositorio encontraremos una carpeta llamada app donde se alojará un fichero llamado app.py ahí debemos crear un fichero llamado wsgi.py con el siguiente contenido.  from app import prog as application  Instalamos los paquetes del requirementes.txt que se aloja también la carpeta app.</description>
    </item>
    
    <item>
      <title>Instalación y configuración de un servidor DNS esclavo </title>
      <link>https://alepeteporico.github.io/ejercicios/dns_ejercicio2/</link>
      <pubDate>Tue, 05 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/ejercicios/dns_ejercicio2/</guid>
      <description>creamos una máquina que actuara de DNS secundario, el primer paso será cambiar el hostname de está maquina.  vagrant@gutierrezvalencia:~$ hostname -f gutierrezvalencia.iesgn.org  Nos dirigimos al DNS primario y configuramos el fichero /etc/bind/named.conf.options  options { directory &amp;quot;/var/cache/bind&amp;quot;; allow-query { 10.0.0.0/24; }; allow-transfer { none; }; auth-nxdomain no; # conform to RFC1035 recursion no; dnssec-validation auto; listen-on-v6 { any; }; };  Y también debemos cambiar el /etc/bind/named.conf.local para añadir el rol de maestro.</description>
    </item>
    
    <item>
      <title>Cortafuegos perimetral sobre el escenario</title>
      <link>https://alepeteporico.github.io/practicas/cortafuegos/</link>
      <pubDate>Mon, 21 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/cortafuegos/</guid>
      <description>Política por defecto DROP para las cadenas INPUT, FORWARD y OUTPUT.  iptables -P INPUT DROP iptables -P OUTPUT DROP iptables -P FORWARD DROP  La máquina Zeus tiene un servidor ssh escuchando por el puerto 22, pero al acceder desde el exterior habrá que conectar al puerto 2222.  iptables -t nat -A PREROUTING -p tcp --dport 2222 -i eth0 -j DNAT --to 172.22.0.169:22 iptables -A INPUT -i eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT iptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT alejandrogv@AlejandroGV:~$ ssh -A debian@172.</description>
    </item>
    
    <item>
      <title>Instalación/migración de aplicaciones web PHP eb tu VPS</title>
      <link>https://alepeteporico.github.io/practicas/cms_php_vps/</link>
      <pubDate>Sun, 20 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/cms_php_vps/</guid>
      <description>Drupal  Primero migraremos la aplicación de drupal que tenemos instalada localmente. para ello vamos a migrar la base de datos.  root@cmsagv:~# mysqldump drupal &amp;gt; ./backup.sql  Migramos la aplicación  alejandrogv@AlejandroGV:~$ scp drupal/ debian@mrrobot.alejandrogv.site/home/debian/  Seguidamente nos iremos a nuestra VPS donde instalaremos mariadb y crearemos una base de datos y un usuario con privilegios sobre ella.  MariaDB [(none)]&amp;gt; CREATE DATABASE drupal; Query OK, 1 row affected (0.</description>
    </item>
    
    <item>
      <title>Servidor DHCP 2022</title>
      <link>https://alepeteporico.github.io/practicas/dhcp_2022/</link>
      <pubDate>Wed, 16 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/dhcp_2022/</guid>
      <description>Creación del escenario  Primero creamos la imagen inicial.  virt-install --connect qemu:///system --cdrom /home/alejandrogv/Escritorio/ISOS/debian-11.1.0-amd64-netinst.iso --network network=bridge --name servidor --memory 1024 --vcpus 1 --disk size=10  Ahora con el volumen que se ha creado crearemos las imagenes de los clientes y el servidor.  sudo qemu-img create -b /var/lib/libvirt/images/servidor.qcow2 -f qcow2 /var/lib/libvirt/images/server.qcow2 sudo qemu-img create -b /var/lib/libvirt/images/servidor.qcow2 -f qcow2 /var/lib/libvirt/images/cliente1.qcow2 sudo qemu-img create -b /var/lib/libvirt/images/servidor.qcow2 -f qcow2 /var/lib/libvirt/images/cliente2.qcow2  Y creamos las máquinas a partir de estas imagenes  sudo virt-install --connect qemu:///system --name server --memory 1024 --vcpus 1 --disk /var/lib/libvirt/images/server.</description>
    </item>
    
    <item>
      <title>Copias de seguridad con bacula</title>
      <link>https://alepeteporico.github.io/practicas/copias/</link>
      <pubDate>Mon, 14 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/copias/</guid>
      <description>Usaremos la herramienta bacula para realizar nuestro sistema de copias de seguridad, por supuesto el primer paso que debemos tomar es instalar el paquete de bacula, instalaremos el cliente en todas las máquinas de nuestro escenario, aunque usaremos zeus para alojar las copias de seguridad.
  Para alojar las copias hemos añadido dos discos que vamos a montar en RAID.
  debian@zeus:~$ df -h Filesystem Size Used Avail Use% Mounted on /dev/md0 9.</description>
    </item>
    
    <item>
      <title>Ejercicio 4 cortafuegos</title>
      <link>https://alepeteporico.github.io/ejercicios/ejercicio4_cortafuegos/</link>
      <pubDate>Fri, 11 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/ejercicios/ejercicio4_cortafuegos/</guid>
      <description>Realizaremos las mismas reglas que en el ejercicio 3, ahora en nftables, para ello usaremos como hicimos el ejercicio 2 la familia inet sobre las tablas de nftables para que valgan tanto para ipv4 como para ipv6. Hagamos las tabalas y cadenas necesarias para empezar.
  Añadimos una regla para tener conexión ssh con la máquina.
  nft add rule inet filter input ip saddr 192.168.1.0/24 tcp dport 22 ct state new,established counter accept nft add rule inet filter output ip daddr 192.</description>
    </item>
    
    <item>
      <title>Ejercicio 3 cortafuegos</title>
      <link>https://alepeteporico.github.io/ejercicios/ejercicio3_cortafuegos/</link>
      <pubDate>Thu, 10 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/ejercicios/ejercicio3_cortafuegos/</guid>
      <description>Tendremos una máquina conectado a dos interfaces red, una que da al exterior y otra interna. Lo una vez preparada debemos hacer una regla snat para que la red interna pueda salir al exterior.  iptables -t nat -A POSTROUTING -s 172.16.0.0/24 -o ens3 -j MASQUERADE  Como hemos estado haciendo vamos a añadir la regla de ssh para poder poner la politica DROP sin problema.  iptables -A INPUT -s 192.</description>
    </item>
    
    <item>
      <title>Ejercicio 2 cortafuegos</title>
      <link>https://alepeteporico.github.io/ejercicios/ejercicio2_cortafuegos/</link>
      <pubDate>Mon, 28 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/ejercicios/ejercicio2_cortafuegos/</guid>
      <description>En este ejercicio realizaremos todos los que hicimos en iptables en el primero ahora con nftables.
  Lo primero que haremos será añadir una tabla donde filtraremos los paquetes, ponemos la familia inet ya que estas reglas deben funcionar tanto en ipv4 como ipv6.
  root@servidor:~# nft add table inet filter  Debemos crear una cadena que acepte los paquete para poder seguir con nuestra conexión ssh.</description>
    </item>
    
    <item>
      <title>SElinux</title>
      <link>https://alepeteporico.github.io/practicas/selinux/</link>
      <pubDate>Fri, 18 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/selinux/</guid>
      <description>En esta práctica vamos a habilitar SELinux en un servidor rocky, en este servidor tendremos alojados un SAMBA y NFS, tendremos que asegurarnos que esto servicios funcionan correctamente con SELinux activado y nuestros clientes pueden usarlos sin problemas.
  Hemos instalado y configurado un servidor samba y nfs en una máquina servidor.
  [vagrant@server ~]$ sudo systemctl status smb.service ● smb.service - Samba SMB Daemon Loaded: loaded (/usr/lib/systemd/system/smb.</description>
    </item>
    
    <item>
      <title>Recolección de logs mediante journald</title>
      <link>https://alepeteporico.github.io/practicas/logs/</link>
      <pubDate>Fri, 04 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/logs/</guid>
      <description>Vamos a usar el paquete systemd-journal-remote primero deberemos instalarlo en nuestro servidor principal, hemos escogido ares y también deberemos instalarlo en nuestros clientes.  usuario@ares:~$ sudo apt install systemd-journal-remote  Vamos a habilitar dos componentes de systemd necesarios para recibir los logs.  usuario@ares:~$ sudo systemctl enable --now systemd-journal-remote.socket Created symlink /etc/systemd/system/sockets.target.wants/systemd-journal-remote.socket -&amp;gt; /lib/systemd/system/systemd-journal-remote.socket. usuario@ares:~$ sudo systemctl enable systemd-journal-remote.service  Y en los clientes también debemos habilitar uno.  [hera@hera ~]$ sudo systemctl enable systemd-journal-upload.</description>
    </item>
    
    <item>
      <title>Ejercicio 1 cortafuegos</title>
      <link>https://alepeteporico.github.io/ejercicios/ejercicio1_cortafuegos/</link>
      <pubDate>Thu, 03 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/ejercicios/ejercicio1_cortafuegos/</guid>
      <description>Añadiremos las siguientes reglas.  # Limpiamos las tablas iptables -F iptables -t nat -F iptables -Z iptables -t nat -Z # Establecemos la política iptables -P INPUT DROP iptables -P OUTPUT DROP iptables -A INPUT -i lo -p icmp -j ACCEPT iptables -A OUTPUT -o lo -p icmp -j ACCEPT iptables -A INPUT -s 192.168.121.0/24 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT iptables -A OUTPUT -d 192.</description>
    </item>
    
    <item>
      <title>Ejercicios kubernetes</title>
      <link>https://alepeteporico.github.io/ejercicios/ejercicos_kubernetes/</link>
      <pubDate>Thu, 03 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/ejercicios/ejercicos_kubernetes/</guid>
      <description>Ejercicio 1  Pantallazo con la salida de minikube status y pantallazo con la salida de kubectl get nodes -o wide.  alejandrogv@AlejandroGV:~$ minikube status minikube type: Control Plane host: Running kubelet: Running apiserver: Running kubeconfig: Configured alejandrogv@AlejandroGV:~$ kubectl get nodes -o wide NAME STATUS ROLES AGE VERSION INTERNAL-IP EXTERNAL-IP OS-IMAGE KERNEL-VERSION CONTAINER-RUNTIME minikube Ready control-plane,master 6d23h v1.23.1 192.168.39.156 &amp;lt;none&amp;gt; Buildroot 2021.02.4 4.19.202 docker://20.10.12 Ejercicio 2  Fichero yaml que has creado con la definición del Pod.</description>
    </item>
    
    <item>
      <title>Aplicación php en docker</title>
      <link>https://alepeteporico.github.io/practicas/docker_bookmedik/</link>
      <pubDate>Wed, 02 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/docker_bookmedik/</guid>
      <description>Tarea 1: Creación de una imagen docker con una aplicación web desde una imagen base   url del repositorio GitHub donde tengas los ficheros necesarios para hacer la construcción de la imagen.
  Imagen docker con la aplicación desde una imagen base de debian o ubuntu. En el registro de tu entorno de desarrollo.
  alejandrogv@AlejandroGV:~/Escritorio/ASIR/IWEB/docker_bookmedik$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE alejandro/bookmedik v1 ee540637fb01 8 seconds ago 309MB Tarea 2: Despliegue en el entorno de desarrollo   url del repositorio GitHub donde hayas añadido el fichero docker-compose.</description>
    </item>
    
    <item>
      <title>Correo en la VPS</title>
      <link>https://alepeteporico.github.io/practicas/correo/</link>
      <pubDate>Wed, 02 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/correo/</guid>
      <description>Documenta una prueba de funcionamiento, donde envíes desde tu servidor local al exterior. Muestra el log donde se vea el envío. Muestra el correo que has recibido. Muestra el registro SPF.  debian@mrrobot:~$ mail tojandro@gmail.com Cc: Subject: prueba desde vps debian@mrrobot:~$ cat /var/log/mail.log Feb 2 07:39:58 mrrobot postfix/pickup[915259]: E42DCA0AB9: uid=1000 from=&amp;lt;debian@mrrobot.alejandrogv.site&amp;gt; Feb 2 07:39:58 mrrobot postfix/cleanup[916025]: E42DCA0AB9: message-id=&amp;lt;20220202073958.E42DCA0AB9@mrrobot.alejandrogv.site&amp;gt; Feb 2 07:39:58 mrrobot postfix/qmgr[915260]: E42DCA0AB9: from=&amp;lt;debian@mrrobot.alejandrogv.site&amp;gt;, size=375, nrcpt=1 (queue active) Feb 2 07:39:59 mrrobot postfix/smtp[916027]: connect to gmail-smtp-in.</description>
    </item>
    
    <item>
      <title>Contenedores LXC</title>
      <link>https://alepeteporico.github.io/practicas/lxc/</link>
      <pubDate>Wed, 19 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/lxc/</guid>
      <description>Creación   Crearemos la primera máquina de nuestro escenario, será un contenedor LXC llamado router. Este contenedor se creará a partir de la plantilla Debian Bullseye. Este contenedor tendrá dos interfaces de red: la primera conectada a una red pública (bridge br0). Por esta interfaz el contenedor tendrá acceso a internet. Además estará conectada la bridge de un red muy aislada que crearás con virsh y tendrá como dirección IP la 10.</description>
    </item>
    
    <item>
      <title>Ejercicios de docker</title>
      <link>https://alepeteporico.github.io/ejercicios/ejercicios_docker/</link>
      <pubDate>Wed, 19 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/ejercicios/ejercicios_docker/</guid>
      <description>Introducción   Crearemos un contenedor demonio a partir de la imagen nginx, el contenedor se debe llamar servidor_web y se debe acceder a él utilizando el puerto 8181 del ordenador donde tengas instalado docker.
  Creación y comprobación de que funciona el contenedor
  alejandrogv@AlejandroGV:~$ docker run --name servidor_web -p 8181:80 -d nginx 964b2c315b83655e5d662a88e620a23f1eaac38666cc64170cd5cd62db72e5fd alejandrogv@AlejandroGV:~$ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 964b2c315b83 nginx &amp;quot;/docker-entrypoint.</description>
    </item>
    
    <item>
      <title>Configuración inicial de LDAP</title>
      <link>https://alepeteporico.github.io/ejercicios/configuracion_ldap/</link>
      <pubDate>Fri, 14 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/ejercicios/configuracion_ldap/</guid>
      <description>LDAP es un protocolo de tipo cliente-servidor para acceder a un servicio de directorio. Un directorio es como una base de datos, pero en general contiene información más descriptiva y más basada en atributos. Realizaremos esta configuración inicial en nuestro escenario en kvm, en contreto en nuestra maquina apolo, la cual entre otras cosas contiene por ejemplo nuestro dns  Empezemos con la instalación del paquete de ldap.  debian@apolo:~$ sudo apt install slapd  Durante esta instalación tendremos que introducir una contraseña para el administrador.</description>
    </item>
    
    <item>
      <title>Ejercicio correo</title>
      <link>https://alepeteporico.github.io/ejercicios/ejercicio_correo/</link>
      <pubDate>Fri, 14 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/ejercicios/ejercicio_correo/</guid>
      <description>Ejercicio 1: Envío local, entre usuarios del mismo servidor   Tenemos distintos parametros configurables, como por ejemplo en el fichero /etc/postfix/main.cf podemos configurar el parametro myorigin que es el dominio donde se va a enviar nuestro correo y mydestination se refiere a los dominios que considera que son suyos, si llegara algun correo a a cualquiera de los dominios que añadamos el servidor recibirá estos correos. Y otro que usaremos más adelante es el relayhost, aquí podremos añadir un servidor de correo que redirija nuestros envios.</description>
    </item>
    
    <item>
      <title>iSCSI</title>
      <link>https://alepeteporico.github.io/practicas/iscsi/</link>
      <pubDate>Thu, 06 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/iscsi/</guid>
      <description>Configura un escenario con vagrant o similar que incluya varias máquinas que permita realizar la configuración de un servidor iSCSI y dos clientes (uno linux y otro windows). Explica de forma detallada en la tarea los pasos realizados.   Crea un target con una LUN y conéctala a un cliente GNU/Linux. Explica cómo escaneas desde el cliente buscando los targets disponibles y utiliza la unidad lógica proporcionada, formateándola si es necesario y montándola.</description>
    </item>
    
    <item>
      <title>Interconexión de servidores de bases de datos</title>
      <link>https://alepeteporico.github.io/practicas/interconexion/</link>
      <pubDate>Mon, 03 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/interconexion/</guid>
      <description>Realizar un enlace entre dos servidores de bases de datos ORACLE, explicando la configuración necesaria en ambos extremos y demostrando su funcionamiento.
  Realizar un enlace entre dos servidores de bases de datos Postgres, explicando la configuración necesaria en ambos extremos y demostrando su funcionamiento.
  Realizar un enlace entre un servidor ORACLE y otro Postgres o MySQL empleando Heterogeneus Services, explicando la configuración necesaria en ambos extremos y demostrando su funcionamiento.</description>
    </item>
    
    <item>
      <title>DNS, servidor web y base de datos</title>
      <link>https://alepeteporico.github.io/practicas/server_web_bbdd_dns/</link>
      <pubDate>Fri, 10 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/server_web_bbdd_dns/</guid>
      <description>Servidor DNS  Configuramos el fichero &amp;ldquo;/etc/bind/named.conf.options&amp;rdquo; y añadimos las siguientes líneas:   listen-on { any; }; allow-transfer { none; }; recursion yes; allow-recursion { any; }; *Configuramos el DNS local, la DMZ y externa en el fichero de configuración /etc/bind/named.conf.local:
view interna { match-clients { 10.0.1.0/24; 127.0.0.1; }; allow-recursion { any; }; zone &amp;quot;alexgv.gonzalonazareno.org&amp;quot; { type master; file &amp;quot;db.alexgv.interna&amp;quot;; }; zone &amp;quot;1.0.10.in-addr-arpa&amp;quot; { type master; file &amp;quot;db.1.0.10&amp;quot;; }; zone &amp;quot;16.</description>
    </item>
    
    <item>
      <title>VPN</title>
      <link>https://alepeteporico.github.io/practicas/vpn/</link>
      <pubDate>Thu, 09 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/vpn/</guid>
      <description>VPN de acceso remoto con OpenVPN y certificados x509  Tenemos dos equipos en vagrant a los que queremos configurarles una conexión VPN. empezemos con el servidor, este está conectado a una red 10.99.99.0/24 a parte de la red que usamos para conectarnos a esta y una interna.  vagrant@servidor:~$ ip a 1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.</description>
    </item>
    
    <item>
      <title>Btrfs</title>
      <link>https://alepeteporico.github.io/practicas/btrfs/</link>
      <pubDate>Thu, 02 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/btrfs/</guid>
      <description>Tenemos una maquina con varios discos asociados, lo primero que haremos será instalar la paquetería necesaria para el uso de este sistema de archivos.  vagrant@maquina1:~$ sudo apt install btrfs-progs arch-install-scripts  Montamos en la tabla de particiones los nuevos discos.  vagrant@maquina1:~$ sudo cfdisk -z /dev/vdb vagrant@maquina1:~$ sudo cfdisk -z /dev/vdc vagrant@maquina1:~$ sudo cfdisk -z /dev/vdd vagrant@maquina1:~$ sudo cfdisk -z /dev/vde  Y vamos a crear el sisitema de ficheros de cada una.</description>
    </item>
    
    <item>
      <title>PLSQL</title>
      <link>https://alepeteporico.github.io/ejercicios/plsql/</link>
      <pubDate>Tue, 23 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/ejercicios/plsql/</guid>
      <description>Realiza una función que reciba el código de un aerogenerador y una fecha y devuelva el total de energía producida en esa fecha. Debes controlar las siguientes excepciones: Aerogenerador inexistente y Aerogenerador en desconexión durante ese día.  BEGIN
END;</description>
    </item>
    
    <item>
      <title>Certificados Digitales</title>
      <link>https://alepeteporico.github.io/practicas/certficiados/</link>
      <pubDate>Mon, 22 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/certficiados/</guid>
      <description>Primero obtendremos nuestro certificado digital en la sede electrónica siguiendo todos los pasos que se nos indican.
  Una vez tengamos nuestro certificado digital podemos importarlo a cualquier navegador, en mi caso quiero importarlo a un navegador firefox que tengo en mi sistema debian 10. Para ello nos dirigiremos a preferencias &amp;gt; Privaciad y Seguridad &amp;gt; Certificados &amp;gt; Ver certificados aquí aparecerá una vetana emergente donde podremos ver todos los certificados guardados que tenemos.</description>
    </item>
    
    <item>
      <title>Integridad, firmas y autentificación</title>
      <link>https://alepeteporico.github.io/practicas/firmas/</link>
      <pubDate>Thu, 18 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/firmas/</guid>
      <description>Tarea 1:  Firmamos un fichero que enviaremos a nuestros compañeros para que comprueben nuestra firma:  alejandrogv@AlejandroGV:~/Descargas$ gpg --output fichero.sign --sign fichero.txt  He enviado un archivo firmado a un compañero que dispone de mi clave pública, los dos hemos verificado la firma.  alejandrogv@AlejandroGV:~/Descargas$ gpg --verify p2pdf.pdf.sign gpg: Firmado el jue 18 nov 2021 12:25:18 CET gpg: usando RSA clave 47742CCB469EB70E132966EDEDA6F79F602CACBD gpg: Firma correcta de &amp;quot;Daniel Miguel Mesa Mejias &amp;lt;danimesamejias@gmail.</description>
    </item>
    
    <item>
      <title>Despliegue de una aplicación python</title>
      <link>https://alepeteporico.github.io/practicas/despliegue_python/</link>
      <pubDate>Tue, 16 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/despliegue_python/</guid>
      <description>Vamos a desarrollar la aplicación del tutorial de django 3.1. Vamos a configurar tu equipo como entorno de desarrollo para trabajar con la aplicación.   Realizamos un fork de la aplicación añadiendola a nuestros repositorios y seguidamente lo clonaremos en nuestra maquina:  alejandrogv@AlejandroGV:~/Escritorio/ASIR/IWEB/despliegue_python$ git clone git@github.com:alepeteporico/django_tutorial.git  Crearemos el entorno virtual donde instalaremos las dependencias necesarias para hacer funcionar nuestra aplicación.  alejandrogv@AlejandroGV:~/Escritorio/ASIR/IWEB$ python3 -m venv django (django) alejandrogv@AlejandroGV:~/Escritorio/ASIR/IWEB$ pip install -r despliegue_python/django_tutorial/requirements.</description>
    </item>
    
    <item>
      <title>Migración de CentOS 8 a Rocky</title>
      <link>https://alepeteporico.github.io/ejercicios/migracion_rocky/</link>
      <pubDate>Fri, 12 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/ejercicios/migracion_rocky/</guid>
      <description>Vamos a usar la distribución Rocky porque es una instalación sencilla, esta distribución está sopoprtada de la misma forma que estaba soportada CentOS. Esto nos asegura que tendremos nuestro sistema actualizado tal como teníamos CentOS, es más, esto no es mas que una distribución &amp;ldquo;hija&amp;rdquo; de la CentOS creada simplemente para sustituir a esta distribución ya sin soporte. Y es exactamente lo que haremos.    Comprobamos la version de centos que tenemos  [centos@migracion ~]$ hostnamectl Static hostname: migracion.</description>
    </item>
    
    <item>
      <title>Cifrado asimétrico con gpg y openssl</title>
      <link>https://alepeteporico.github.io/practicas/asimetrico/</link>
      <pubDate>Thu, 11 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/asimetrico/</guid>
      <description>Tarea 1: Generación de claves  Generamos las claves:  alejandrogv@AlejandroGV:~$ gpg --gen-key gpg (GnuPG) 2.2.27; Copyright (C) 2021 Free Software Foundation, Inc. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Nota: Usa &amp;quot;gpg --full-generate-key&amp;quot; para el diálogo completo de generación de clave. GnuPG debe construir un ID de usuario para identificar su clave. Nombre y apellidos: ALejandro Gutiérrez Valencia Dirección de correo electrónico: tojandro@gmail.</description>
    </item>
    
    <item>
      <title>Boletín de Triggers</title>
      <link>https://alepeteporico.github.io/ejercicios/boletin_triggers/</link>
      <pubDate>Tue, 09 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/ejercicios/boletin_triggers/</guid>
      <description>Haz un trigger que solo permita a los vendedores tener comisiones. CREATE OR REPLACE TRIGGER Com_vend BEFORE INSERT OR UPDATE ON emp BEGIN IF JOB!=&#39;Vendedor&#39; THEN RAISE_APPLICATION_ERROR(-20100,&#39;Los empleados que no sean vendedores no pueden tener comisiones&#39;); END IF; END; Registrar todas las operaciones sobre la tabla EMP de SCOTT en una tabla llamada AUDIT_EMP donde se guarde usuario, fecha, tipo de operación y datos que ha modificado. CREATE OR REPLACE TRIGGER audit_empleados AFTER INSERT OR UPDATE OR DELETE ON emp BEGIN INSERT INTO AUDIT_EMP() </description>
    </item>
    
    <item>
      <title>Desplegando aplicaciones flask con apache2 &#43; gunicorn</title>
      <link>https://alepeteporico.github.io/ejercicios/gunicorn/</link>
      <pubDate>Tue, 09 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/ejercicios/gunicorn/</guid>
      <description>Vamos a instalar este cms llamado gunicorn, para ello creamos un entorno virutal y lo instalamos:  (gunicorn) vagrant@cmsagv:~$ pip install gunicorn  Vamos a instalar las dependencias del fichero requirements  (gunicorn) vagrant@cmsagv:~/guestbook/app$ pip install -r requirements.txt  Ahora vamos a crear un virtualhost donde añadiremos el modulo de proxy inverso ya. Y moveremos el guestbook a /var/www/  &amp;lt;VirtualHost *:80&amp;gt; ServerName www.alegv-guestbook.com DocumentRoot /var/www/guestbook/app/ ProxyPass / http://127.0.0.1:8080/ ProxyPassReverse / http://127.</description>
    </item>
    
    <item>
      <title>Desplegando aplicaciones flask con apache2 &#43; mod_wsgi</title>
      <link>https://alepeteporico.github.io/ejercicios/wsgi/</link>
      <pubDate>Tue, 09 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/ejercicios/wsgi/</guid>
      <description>Creamos un entorno virtual y lo activamos:  alejandrogv@AlejandroGV:~/entornos$ python3 -m venv wsgi alejandrogv@AlejandroGV:~/entornos$ source wsgi/bin/activate  Vamos a instalar los paquetes necesarios  pip install flask redis  Tenemos que instalar el módulo de apache para que wsgi funcione  sudo apt install libapache2-mod-wsgi-py3  Clonamos el respositorio con la aplicación.  (wsgi) alejandrogv@AlejandroGV:~/Escritorio/ASIR/IWEB/wsgi$ git clone https://github.com/josedom24/guestbook.git  Ahora creamos un fichero en el respositorio llamado wsgi.py dentro de la carpeta app donde añadiremos la siguiente línea:  from app import prog as application  Creamos un virtual host con la siguiente configuración:  &amp;lt;VirtualHost *:80&amp;gt; ServerName www.</description>
    </item>
    
    <item>
      <title>Ejercicio 1 DNS</title>
      <link>https://alepeteporico.github.io/ejercicios/ejercico1_dns/</link>
      <pubDate>Mon, 08 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/ejercicios/ejercico1_dns/</guid>
      <description>Empezaremos a añadir las zonas de las que nuestro servidor tiene autoridad en el fichero /etc/bind/named.conf.local, dejandolo tal que así (tener en cuenta que hay que descomentar la primera línea).  include &amp;quot;/etc/bind/zones.rfc1918&amp;quot;; zone &amp;quot;iesgn.org&amp;quot; { type master; file &amp;quot;db.iesgn.org&amp;quot;; }; zone &amp;quot;0.0.10.in-addr.arpa&amp;quot; { type master; file &amp;quot;db.0.0.10&amp;quot;; };  Ahora definiremos los fichero db.iesgn.org y db.0.0.10 dentro de /var/cache/bind/ vamos primero con la zona directa:  $TTL 86400 @ IN SOA alegv.</description>
    </item>
    
    <item>
      <title>Escenario KVM</title>
      <link>https://alepeteporico.github.io/practicas/escenario_kvm/</link>
      <pubDate>Mon, 08 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/escenario_kvm/</guid>
      <description>Definamos nuestra red interna llamada interna_agv en un fichero xml.  &amp;lt;network&amp;gt; &amp;lt;name&amp;gt;interna_agv&amp;lt;/name&amp;gt; &amp;lt;forward mode=&amp;quot;bridge&amp;quot;/&amp;gt; &amp;lt;bridge name=&amp;quot;br0&amp;quot;/&amp;gt; &amp;lt;/network&amp;gt;  Vamos a crear la red.  alejandrogv@AlejandroGV:~/kvm/redes$ virsh -c qemu:///system net-create --file interna_agv.xml La red interna_agv ha sido creada desde interna_agv.xml  Y hacemos lo mismo con la red DMZ.  &amp;lt;network&amp;gt; &amp;lt;name&amp;gt;interna_agv&amp;lt;/name&amp;gt; &amp;lt;forward mode=&amp;quot;bridge&amp;quot;/&amp;gt; &amp;lt;bridge name=&amp;quot;br0&amp;quot;/&amp;gt; &amp;lt;/network&amp;gt; alejandrogv@AlejandroGV:~/kvm/redes$ virsh -c qemu:///system net-create --file dmz.xml La red dmz_agv ha sido creada desde dmz.</description>
    </item>
    
    <item>
      <title>Módulos en apache</title>
      <link>https://alepeteporico.github.io/ejercicios/modulos_apache/</link>
      <pubDate>Mon, 08 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/ejercicios/modulos_apache/</guid>
      <description>UserDIR   Este módulo nos permitirá que cada usuario tenga una carpeta en su home llamada public_html donde podrá añadir contenido web.
  Vamos a instalar este módulo:
  vagrant@cmsagv:~$ sudo a2enmod userdir  Ahora creamos la carpeta public_html y le damos los permisos necesarios.  vagrant@cmsagv:~$ mkdir public_html vagrant@cmsagv:~$ sudo chmod 0755 public_html/  Y ya tenemos nuestro directorio donde podemos subir contenido. Aunque podemos cambiar el nombre de esta carpeta, vamos a llamarla personal y para que el módulo pueda ver el cambio vamos al fichero /etc/apache2/mods-enabled/php7.</description>
    </item>
    
    <item>
      <title>Configuración del escenario router-nat con vagrant y ansible</title>
      <link>https://alepeteporico.github.io/practicas/ejercicio3_vagrant_ansible/</link>
      <pubDate>Sat, 06 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/ejercicio3_vagrant_ansible/</guid>
      <description></description>
    </item>
    
    <item>
      <title>DNS</title>
      <link>https://alepeteporico.github.io/apuntes/dns_2021/</link>
      <pubDate>Fri, 05 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/apuntes/dns_2021/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Migración de aplicación web PHP</title>
      <link>https://alepeteporico.github.io/practicas/migracion_durpal/</link>
      <pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/migracion_durpal/</guid>
      <description>Nos daremos de alta en un hosting gratuito, en mi caso cdmon. Y crearemos un nuevo hosting.  Migración de la base de datos.  Lo primero que haremos será restaurar nuestra base de datos en nuestro hosting, para ello entraremos en la pestaña de mysql.   Creamos una nueva base de datos, en mi caso la llamaré joomlaagv.   y accederemos a phpMyAdmin con las credenciales que se nos otorgan.</description>
    </item>
    
    <item>
      <title>Instalación local de un CMS PHP</title>
      <link>https://alepeteporico.github.io/practicas/cmsphp_local/</link>
      <pubDate>Tue, 02 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/cmsphp_local/</guid>
      <description>VagrantFile Vagrant.configure(&amp;quot;2&amp;quot;) do |config| config.vm.define :cmsagv do |cmsagv| cmsagv.vm.box = &amp;quot;debian/bullseye64&amp;quot; cmsagv.vm.hostname = &amp;quot;cmsagv&amp;quot; cmsagv.vm.network &#39;private_network&#39;, :ip =&amp;gt; &#39;192.168.100.200&#39; cmsagv.vm.network :private_network, :libvirt__network_name =&amp;gt; &amp;quot;red1&amp;quot;, :libvirt__dhcp_enabled =&amp;gt; false, :ip =&amp;gt; &amp;quot;172.22.100.5&amp;quot;, :libvirt__forward_mode =&amp;gt; &amp;quot;none&amp;quot; end config.vm.define :backup do |backup| backup.vm.box = &amp;quot;debian/bullseye64&amp;quot; backup.vm.hostname = &amp;quot;backup&amp;quot; backup.vm.network :private_network, :libvirt__network_name =&amp;gt; &amp;quot;red1&amp;quot;, :libvirt__dhcp_enabled =&amp;gt; false, :ip =&amp;gt; &amp;quot;172.22.100.10&amp;quot;, :libvirt__forward_mode =&amp;gt; &amp;quot;none&amp;quot; end end Instalamos un servidor LAMP
Apache Hacemos una instalación sencilla:
vagrant@cmsalegv:~$ sudo apt install apache2 apache2-utils  Y creamos una regla en iptables para permitir la conexión http</description>
    </item>
    
    <item>
      <title>Gestión de paquetería en debian</title>
      <link>https://alepeteporico.github.io/practicas/paqueteria/</link>
      <pubDate>Fri, 01 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/paqueteria/</guid>
      <description>APT, APTITUDE Y DPKG  Que acciones consigo al realizar apt update y apt upgrade. Explica detalladamente.    update: actualiza la lista de paquetes que están disponibles y la versión actual usando los repositorios que se alojan en el fichero sources.list
  upgrade: Esta opción la usaríamos después del update, pues la lista de paquetes y sus versiones estaría actualizada y este comando instalaría estas nuevas versiones</description>
    </item>
    
    <item>
      <title>Uso básico de libvirt</title>
      <link>https://alepeteporico.github.io/ejercicios/libvirt_basico/</link>
      <pubDate>Thu, 30 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/ejercicios/libvirt_basico/</guid>
      <description>Creación de la red.   La red que vamos a crear para este ejercicio será tipo NAT, tendrá direccionamiento 10.0.1.0/24 y de tipo virtio.
  Veamos el contenido del fichero xml de configuración de la red.
  &amp;lt;network&amp;gt; &amp;lt;name&amp;gt;red_interna&amp;lt;/name&amp;gt; &amp;lt;bridge name=&amp;quot;virbr20&amp;quot;/&amp;gt; &amp;lt;forward mode=&amp;quot;nat&amp;quot;/&amp;gt; &amp;lt;ip address=&amp;quot;10.0.1.0&amp;quot; netmask=&amp;quot;255.255.255.0&amp;quot;&amp;gt; &amp;lt;dhcp&amp;gt; &amp;lt;range start=&amp;quot;10.0.1.2&amp;quot; end=&amp;quot;10.0.1.254&amp;quot;/&amp;gt; &amp;lt;/dhcp&amp;gt; &amp;lt;/ip&amp;gt; &amp;lt;/network&amp;gt;  Creamos esta red.  alejandrogv@AlejandroGV:~/libvirt$ virsh -c qemu:///system net-create red_interna.xml Creación de escenario.</description>
    </item>
    
    <item>
      <title>Implantación y despliegue de una aplicación web estática 2021</title>
      <link>https://alepeteporico.github.io/practicas/web_estatica/</link>
      <pubDate>Wed, 29 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/web_estatica/</guid>
      <description>Vamos a realizar e implementar una aplicación web estática, para ello usaremos el generador de páginas estáticas jekyll y usaremos para implementarlo surge. jekyll  Para la instalación de jekyll primero debemos asegurarnos de tener instalado ruby y algunas dependencias ya que la aplicación está escrita en este lenguaje.  sudo apt install ruby ruby-dev  Y ahora si podemos instalar jekyll.  sudo gem install bundler jekyll  Ahora crearemos nuestro sitio web en el entorno de desarrollo  jekyll new jekyll_dinamico  Vamos a visualizar el contenido de este sitio que se nos ha generado por defecto.</description>
    </item>
    
    <item>
      <title>Herramientas de seguridad</title>
      <link>https://alepeteporico.github.io/practicas/herramientas_de_seguridad/</link>
      <pubDate>Thu, 23 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/herramientas_de_seguridad/</guid>
      <description>Sistemas de detección de intrusos  Vamos a usar como sistema de detección de intrusos la herramienta SURICATA, parece ser la más usada a día de hoy   Vamos a instalar el paquete de suricata y oinkmaster que usaremos mas adelante.  root@suricata:~# apt install suricata  La instalación ha sido sencilla, para configurar los parametros básicos iremos al fichero /etc/suricata/suricata.yaml, lo primero que haremos será asegurarnos que suricata escucha por la interfaz correcta.</description>
    </item>
    
    <item>
      <title>Instalación desatendida de debian</title>
      <link>https://alepeteporico.github.io/apuntes/instalacion_desatendida_debian11/</link>
      <pubDate>Tue, 21 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/apuntes/instalacion_desatendida_debian11/</guid>
      <description>Nos dirijiremos a la página oficial de debian para descargar la ISO de debian que usaremos en nuestro caso debian 11.
 alejandrogv@AlejandroGV:~/Escritorio/ISOS$ ls ... debian-11.0.0-amd64-netinst.iso ...    Montaremos esta imagen en una carpeta donde elijamos para después modificar su contenido
 alejandrogv@AlejandroGV:~/Escritorio/ISOS$ sudo mount -o loop debian-11.0.0-amd64-netinst.iso preseed/ alejandrogv@AlejandroGV:~/Escritorio/ISOS$ ls preseed/ autorun.inf dists g2ldr isolinux README.html README.txt boot doc g2ldr.mbr md5sum.txt README.mirrors.html setup.exe css EFI install pics README.</description>
    </item>
    
    <item>
      <title>Instalación y configuración de un servidor PXE en debian</title>
      <link>https://alepeteporico.github.io/practicas/pxe/</link>
      <pubDate>Tue, 21 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/pxe/</guid>
      <description>En la máquina que usaremos como servidor pxe debemos instalar también un servidor dhcp que dará direccionamiento IP a nuestros clientes.
 vagrant@pxe:~$ sudo apt install isc-dhcp-server    Ahora en el fichero /etc/dhcp/dhcpd.conf añadimos la configuración de nuestro dhcp.
  option domain-name «servidorpxe.com»; option domain-name-servers «server1.servidorpxe.com»; subnet 192.168.1.100 netmask 255.255.255.0 { range 192.168.1.10 192.168.1.30; option routers 192.168.1.1; option broadcast-address 192.168.1.255; } default-lease-time 600; max-lease-time 7200 authoritative;  Vamos a instalar los paquetes necesarios para nuestro servidor pxe  vagrant@pxe:~$ sudo apt install apache2 tftpd-hpa inetutils-inetd  Ahora añadimos al fichero /etc/default/tftpd-hpa las siguientes líneas para iniciar el demonio.</description>
    </item>
    
    <item>
      <title>Instalación de wordpress</title>
      <link>https://alepeteporico.github.io/apuntes/wordpress/</link>
      <pubDate>Mon, 20 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/apuntes/wordpress/</guid>
      <description>El cms elegido es wordpress, los descargamos y descomprimimos en primer lugar como hicimos con drupal
vagrant@cmsagv:~$ wget https://es.wordpress.org/latest-es_ES.tar.gz vagrant@cmsagv:~$ sudo tar xf latest-es_ES.tar.gz -C /var/www/ vagrant@cmsagv:~$ sudo chown www-data:www-data /var/www/wordpress/ -R  Nuevamente creamos una nueva base de datos y otorgamos privilegios a nuestro usario dentro de la misma.
MariaDB [(none)]&amp;gt; CREATE DATABASE wordpress; Query OK, 1 row affected (0.000 sec) MariaDB [(none)]&amp;gt; GRANT ALL PRIVILEGES ON wordpress.* to &#39;usuario2&#39;@&#39;172.</description>
    </item>
    
    <item>
      <title>Lo básico de ansible</title>
      <link>https://alepeteporico.github.io/apuntes/ansible-basico/</link>
      <pubDate>Mon, 20 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/apuntes/ansible-basico/</guid>
      <description>    </description>
    </item>
    
    <item>
      <title>PLSQL apuntes</title>
      <link>https://alepeteporico.github.io/apuntes/plsql_apuntes/</link>
      <pubDate>Mon, 20 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/apuntes/plsql_apuntes/</guid>
      <description>TRIGGERS  Trozo de código que se ejecuta cuando sucede algo que especifiquemos.  Triggers de datos   Se asocian a operaciones que modifica datos de las tablas de la base de datos.
  Creación del trigger:
  Momento: BEFORE, AFTER O INSTEAD OF
 BEFORE: Antes de la instrucción DML que queramos hacer, normalmente sirve para hacer comprobaciones y saber si realizar esa instrucción o no AFTER: Normalmente usado para saber si se ha realizado esa sentencia.</description>
    </item>
    
    <item>
      <title>Pull Request</title>
      <link>https://alepeteporico.github.io/apuntes/pull_request/</link>
      <pubDate>Sun, 19 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/apuntes/pull_request/</guid>
      <description>Vamos a hacer un pull request de un repositorio perteneciente a otra persona. Pull Request  Para ello debemos hacer un fork en github de su repositorio y entonces clonar ese fork que ahora está en nuestro repositorio, una vez clonado entramos en el repositorio y creamos una nueva rama.  alejandrogv@AlejandroGV:~/Escritorio/ASIR/IWEB/prueba-pr-asir$ git checkout -b mi_proyecto Cambiado a nueva rama &#39;mi_proyecto&#39;  Después de realizar los cambios que necesitemos los agregamos a nuestra rama.</description>
    </item>
    
    <item>
      <title>Compilación de un kérnel linux a medida</title>
      <link>https://alepeteporico.github.io/practicas/kernel/</link>
      <pubDate>Fri, 17 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/kernel/</guid>
      <description>Vamos a necesitar instalar cierta paquetería como vemos a continuación.
 alejandrogv@AlejandroGV:~/Escritorio/ASIR/sistemas/kernel$ sudo apt install build-essential qtbase5-dev    Necesitamos saber que versión del kernel estamos usando.
 alejandrogv@AlejandroGV:~/Escritorio/ASIR/sistemas/kernel$ uname -r 5.10.0-8-amd64    Descargaremos la versión de nuestro kernel desde la página oficial
 alejandrogv@AlejandroGV:~/Escritorio/ASIR/sistemas/kernel$ wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.10.tar.gz alejandrogv@AlejandroGV:~/Escritorio/ASIR/sistemas/kernel$ ls linux-5.10.tar.gz    Descomprimos este archivo y el resultado será una carpeta con muchisima información.</description>
    </item>
    
    <item>
      <title>Actualización de Debian 10 a Debian 11</title>
      <link>https://alepeteporico.github.io/practicas/actualizacion_debian11/</link>
      <pubDate>Thu, 16 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/actualizacion_debian11/</guid>
      <description>Actualización   Primero debemos actualizar nuestro debian 10 como tenemos por costumbre hacerlo.
 alejandrogv@AlejandroGV:~$ sudo apt update alejandrogv@AlejandroGV:~$ sudo apt upgrade    Es necesario instalar el paquete gcc-8-base aunque es probable que ya lo tengamos pero nos aseguramos.
 alejandrogv@AlejandroGV:~$ sudo apt install gcc-8-base    Ahora editamos nuestro etc/apt/sources.list para añadir los repositorios del nuevo debian &amp;ldquo;bullseye&amp;rdquo;
 deb http://deb.debian.org/debian/ bullseye main contrib non-free # deb-src http://deb.</description>
    </item>
    
    <item>
      <title>Instalación de debian 11 con LVM</title>
      <link>https://alepeteporico.github.io/practicas/instalacion_debian11/</link>
      <pubDate>Thu, 16 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/instalacion_debian11/</guid>
      <description>Empezamos la instalación y seguimos todos los pasos normalmente hasta llegar a la configuración de los discos, la haremos manualmente y en mi caso he creado una máquina virtual para simular lo que hice en mi máquina anfitriona, para ello he creado una partición sin usar simulando que tengo en ella una partición con Windows 10.   Seguidamente elegiremos la opción de &amp;ldquo;Configurar el gestor de volúmenes lógicos&amp;rdquo; y crearemos un grupo de volúmenes.</description>
    </item>
    
    <item>
      <title>COPIAS DE SEGURIDAD Y RECUPERACIÓN</title>
      <link>https://alepeteporico.github.io/practicas/copiasbbdd/</link>
      <pubDate>Mon, 07 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/copiasbbdd/</guid>
      <description>Primero crearemos el directorio donde almacenaremos las copias.
 SQL&amp;gt; CREATE directory COPIA as &#39;/home/backups/&#39;; Directory created.    Comprobemos que se ha creado correctamente.
 SQL&amp;gt; select directory_name from dba_directories; DIRECTORY_NAME -------------------------------------------------------------------------------- COPIA SDO_DIR_WORK SDO_DIR_ADMIN XMLDIR XSDDIR OPATCH_INST_DIR ORACLE_OCM_CONFIG_DIR2 ORACLE_BASE ORACLE_HOME ORACLE_OCM_CONFIG_DIR DATA_PUMP_DIR DIRECTORY_NAME -------------------------------------------------------------------------------- OPATCH_SCRIPT_DIR OPATCH_LOG_DIR JAVA$JOX$CUJS$DIRECTORY$ 14 rows selected.     expdp ale/ale dumpfile=copia_oracle_export_%U.dmp logfile=copia_oracle_export.log directory=CARPETA_EXPORT full=y filesize=100M</description>
    </item>
    
    <item>
      <title>Cortafuegos - OpenStack</title>
      <link>https://alepeteporico.github.io/practicas/cortafuegos_antiguo/</link>
      <pubDate>Mon, 07 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/cortafuegos_antiguo/</guid>
      <description>Nuestro primer paso será instalar nftables.
 debian@dulcinea:~$ sudo apt install nftables    Activamos y habilitamos este servicio.
 debian@dulcinea:~$ sudo systemctl start nftables debian@dulcinea:~$ sudo systemctl enable nftables    Configuraremos la política por defecto a DROP.
 nft chain inet filter input { policy drop \; } nft chain inet filter forward { policy drop \; } nft chain inet filter output { policy drop \; }    Añadimos las reglas de NAT.</description>
    </item>
    
    <item>
      <title>Implantación de aplicaciones web PHP en docker</title>
      <link>https://alepeteporico.github.io/practicas/php_docker/</link>
      <pubDate>Mon, 07 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/php_docker/</guid>
      <description>Vamos a clonar el repositorio necesario para la aplicación.
 alejandrogv@AlejandroGV:~/docker/php$ git clone https://github.com/evilnapsis/bookmedik.git    Crearemos un repositorio con la siguiente estructura.
 alejandrogv@AlejandroGV:~/docker/php/php_docker$ tree . ├── build │ ├── bookmedik │ ├── Dockerfile │ └── script.sh ├── deploy │ └── docker-compose.yml └── README.md    En el fichero docker-compose añadimos lo siguiente.
 version: &amp;quot;3.1&amp;quot; services: db: container_name: mysql image: mariadb restart: always environment: MYSQL_DATABASE: bookmedik MYSQL_USER: bookmedik MYSQL_PASSWORD: admin MYSQL_ROOT_PASSWORD: admin volumes: - /opt/mysql_wp:/var/lib/mysql    Y en la carpeta build crearemos un fichero Dockerfile que rellenaremos de la siguiente forma.</description>
    </item>
    
    <item>
      <title>Proxy, proxy inverso y balanceadores de carga</title>
      <link>https://alepeteporico.github.io/practicas/proxy/</link>
      <pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/proxy/</guid>
      <description>Primero usaremos squid para instalar un proxy.
 vagrant@proxy:~$ sudo apt install squid    Modificamos el fichero /etc/squid/squid.conf para definir las direcciones y puertos que permitiremos y el puerto de funcionamiento.
 acl localnet src 10.0.0.0/24 acl localnet src 172.22.100.0/24 acl SSL_ports port 443 acl Safe_ports port 80 # http acl Safe_ports port 21 # ftp acl Safe_ports port 443 # https acl CONNECT method CONNECT # Deny requests to certain unsafe ports http_access deny !</description>
    </item>
    
    <item>
      <title>Aumento de rendimiento de servidores web von Varnish</title>
      <link>https://alepeteporico.github.io/practicas/rendimientoweb/</link>
      <pubDate>Sat, 05 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/rendimientoweb/</guid>
      <description>Instalamos ansible
 alejandrogv@AlejandroGV:~$ sudo apt install ansible    Ahora clonaremos el repositorio correspondiente con la receta.
 alejandrogv@AlejandroGV:~$ git clone https://github.com/josedom24/ansible_nginx_fpm_php.git    En el interior del respositorio editaremos el fichero hosts añadiendo la dirección de la máquina que usaremos para las pruebas.
 [servidores_web] nodo1 ansible_ssh_host=172.22.100.15 ansible_python_interpreter=/usr/bin/python3    Ejecutamos la funcionalidad playbook de ansible para que se realicen las modificaciones necesarias que usaremos en la máquina de prueba.</description>
    </item>
    
    <item>
      <title>Introducción a la integración continua </title>
      <link>https://alepeteporico.github.io/practicas/ic/</link>
      <pubDate>Fri, 04 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/ic/</guid>
      <description>Integración continúa de aplicación django   Ya tenemos nuestra aplicación y el entorno virtual de la práctica de Despliegue de una aplicación python usaremos la misma, y realizaremos los test.
 (django) alejandrogv@AlejandroGV:~/Escritorio/ASIR/IWEB/despliegue_python/django_tutorial$ python3 manage.py test Creating test database for alias &#39;default&#39;... System check identified no issues (0 silenced). .......... ---------------------------------------------------------------------- Ran 10 tests in 0.056s OK Destroying test database for alias &#39;default&#39;...    Vamos a modificar el fichero polls/templates/polls/index.</description>
    </item>
    
    <item>
      <title>LDAP</title>
      <link>https://alepeteporico.github.io/practicas/ldap_openstack/</link>
      <pubDate>Mon, 31 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/ldap_openstack/</guid>
      <description>Para esta práctica vamos a usar las claves y certificados que generamos en la práctica de seguridad de https
 [root@quijote ~]# scp /etc/ssl/certs/gonzalonazareno.crt debian@10.0.1.9 [root@quijote ~]# scp /etc/ssl/certs/openstack.crt debian@10.0.1.9 [root@quijote ~]# scp /etc/ssl/private/openstack.key debian@10.0.1.9    Vamos a mover estos certificados a un sitio apropiado.
 debian@freston:~$ sudo mv gonzalonazareno.crt /etc/ssl/certs/ debian@freston:~$ sudo mv openstack.crt /etc/ssl/certs/ debian@freston:~$ sudo mv openstack.key /etc/ssl/private/    Vamos a crear unas acl para que el usuario openldap que es el encargado de ejecutar los servicios de sldap tenga permisos sobre estos certificados.</description>
    </item>
    
    <item>
      <title>Servidor nginx</title>
      <link>https://alepeteporico.github.io/practicas/nginx/</link>
      <pubDate>Mon, 31 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/nginx/</guid>
      <description>Crea una máquina del cloud con una red pública. Añade la clave pública del profesor a la máquina. Instala el servidor web nginx en la máquina. Modifica la página index.html que viene por defecto y accede a ella desde un navegador.   La IP del servidor es la 172.22.201.5
  Una vez añadida la clave pública del profesor instalamos el servidor web nginx.
 debian@nginx:~$ sudo apt install nginx    Comprobamos que podemos acceder perfectamente desde fuera.</description>
    </item>
    
    <item>
      <title>Despliegue de un cluster de kubernetes</title>
      <link>https://alepeteporico.github.io/practicas/cluster_kubernetes/</link>
      <pubDate>Thu, 27 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/cluster_kubernetes/</guid>
      <description>Crearemos 3 máquinas Vagrant que nos servirán, una de controlador y las otras dos de workers.
  En la máquina que usaremos como controlador descargaremos e instalaremos usando curl el script que instalará el servicio de k3.
 root@servidor:/usr/local/bin# curl -sfL https://get.k3s.io | sh -    Podemos comprobar mediante netstat que se ha abierto un puerto 6443 que es el que usa k3s por defecto.</description>
    </item>
    
    <item>
      <title>OpenStack: Configuración HTTPS</title>
      <link>https://alepeteporico.github.io/practicas/https_openstack/</link>
      <pubDate>Thu, 27 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/https_openstack/</guid>
      <description>El siguiente paso de nuestro proyecto es configurar de forma adecuada el protocolo HTTPS en nuestro servidor web para nuestra aplicaciones web. Para ello vamos a emitir un certificado wildcard en la AC Gonzalo Nazareno utilizando para la petición la utilidad &amp;ldquo;gestiona&amp;rdquo;.   Lo primero que debemos hacer para llevarlo a cabo es dirigirnos a centos donde crearemos los directorios nesarios y crearemos una clave RSA.
 [centos@quijote ~]$ sudo mkdir /etc/ssl/private [centos@quijote ~]$ sudo chmod 700 /etc/ssl/private Generating RSA private key, 4096 bit long modulus (2 primes) .</description>
    </item>
    
    <item>
      <title>Apuntes de SSH</title>
      <link>https://alepeteporico.github.io/apuntes/apuntes-de-ssh-avanzado/</link>
      <pubDate>Sat, 22 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/apuntes/apuntes-de-ssh-avanzado/</guid>
      <description>ssh-agent   Tenemos un par de claves, para añadir a nuestro ssh-agent:
 ssh-add .ssh/clave    Nos pedirá la frase de paso y se añadiría la identidad, para comprobarlo:
 ssh-add -l    Pero necesitamos añadir esa clave a la máquina que nos queremos conectar.
 ssh-copy-id -i .ssh/clave usuario@172.22.100.10    Túneles ssh   Se usa para saltarnos un cortafuegos o para acceder por un canal abierto y más seguro, entre otras útilidades.</description>
    </item>
    
    <item>
      <title>Instalación y configuración de LDAP</title>
      <link>https://alepeteporico.github.io/practicas/ldap/</link>
      <pubDate>Sat, 15 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/ldap/</guid>
      <description>LDAP es un protocolo de tipo cliente-servidor para acceder a un servicio de directorio. Un directorio es como una base de datos, pero en general contiene información más descriptiva y más basada en atributos.
  Lo primero que debemos hacer es verificar nuestro FQDN (Fully Qualified Domain Name) que usaremos mas tarde para la configuración.
 debian@freston:~$ hostname -f freston.alegv.gonzalonazareno.org    Instalaremos el paquete de LDAP
 debian@freston:~$ sudo apt install slapd    Durante esta instalación tendremos que introducir una contraseña para el administrador.</description>
    </item>
    
    <item>
      <title>Almacenamiento</title>
      <link>https://alepeteporico.github.io/practicas/almacenamiento_bbdd/</link>
      <pubDate>Mon, 10 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/almacenamiento_bbdd/</guid>
      <description>Muestra los objetos a los que pertenecen las extensiones del tablespace TS2 (creado por tí) y el tamaño de cada una de ellas. Tendrás que crear objetos en él previamente, claro.   Vamos a crear este Tablespace.
 SQL&amp;gt; CREATE TABLESPACE TS2 2 DATAFILE &#39;/home/oracle/ts2.dbf&#39; 3 SIZE 200K 4 AUTOEXTEND ON 5 DEFAULT STORAGE ( 6 INITIAL 200K 7 NEXT 200K 8 MAXEXTENTS 3 9 PCTINCREASE 100); Tablespace created.    Vamos a crear una prueba para ver como funciona y añadamos contenido a ver como funciona.</description>
    </item>
    
    <item>
      <title>Servidor DNS</title>
      <link>https://alepeteporico.github.io/practicas/dns/</link>
      <pubDate>Mon, 10 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/dns/</guid>
      <description>En nuestra red local tenemos un servidor Web que sirve dos páginas web: www.iesgn.org, departamentos.iesgn.org
  Vamos a instalar en nuestra red local un servidor DNS (lo puedes instalar en el mismo equipo que tiene el servidor web)
  Voy a suponer en este documento que el nombre del servidor DNS va a ser pandora.iesgn.org. El nombre del servidor de tu prácticas será tunombre.iesgn.org.
   DNSmasq Instala el servidor dns dnsmasq en pandora.</description>
    </item>
    
    <item>
      <title>Configuración de apache mediante archivo .htaccess </title>
      <link>https://alepeteporico.github.io/ejercicios/apache_htaccess/</link>
      <pubDate>Sat, 24 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/ejercicios/apache_htaccess/</guid>
      <description>Date de alta en un proveedor de hosting. ¿Si necesitamos configurar el servidor web que han configurado los administradores del proveedor?, ¿qué podemos hacer? Explica la directiva AllowOverride de apache2. Utilizando archivos .htaccess realiza las siguientes configuraciones:  El hosting que usaré será 000webhost  Habilita el listado de ficheros en la URL http://host.dominio/nas.   En nuestro hosting tendremos una carpeta llamada public_html en la cual podremos encontrar un fichero llamado .</description>
    </item>
    
    <item>
      <title>Control de acceso, autentificación y autorización</title>
      <link>https://alepeteporico.github.io/ejercicios/control_acceso/</link>
      <pubDate>Sat, 24 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/ejercicios/control_acceso/</guid>
      <description>Crea un escenario en Vagrant o reutiliza uno de los que tienes en ejercicios anteriores, que tenga un servidor con una red publica, y una privada y un cliente conectada a la red privada. Crea un host virtual departamentos.iesgn.org  Para está práctica podremos usar la misma máquina de vagrant que usamos para las prácticas del cms y de mapeo.  A la URL departamentos.iesgn.org/intranet sólo se debe tener acceso desde el cliente de la red local, y no se pueda acceder desde la anfitriona por la red pública.</description>
    </item>
    
    <item>
      <title>Mapear URL a ubicaciones de un sistema de ficheros</title>
      <link>https://alepeteporico.github.io/ejercicios/mapeo/</link>
      <pubDate>Wed, 21 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/ejercicios/mapeo/</guid>
      <description>Crea un nuevo host virtual que es accedido con el nombre www.mapeo.com, cuyo DocumentRoot sea /srv/mapeo.   En primer lugar para que nuestro apache pueda acceder a /srv/ y reconocer esta ruta como DocumentRoot debemos modificar el fichero etc/apache2/apache2.conf y descomentar las siguientes líneas.
 &amp;lt;Directory /srv/&amp;gt; Options Indexes FollowSymLinks AllowOverride None Require all granted &amp;lt;/Directory&amp;gt;    Una vez hecho esto creamos la carpeta mapeo en /srv/ y añadimos el nuevo host virtual en sites-avaiable, veamos como quedaría el fichero de sites-avaiable.</description>
    </item>
    
    <item>
      <title>Instalación de servidores y clientes</title>
      <link>https://alepeteporico.github.io/practicas/serv_client/</link>
      <pubDate>Mon, 05 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/serv_client/</guid>
      <description>Tras la instalación de cada servidor, debe crearse una base de datos con al menos tres tablas o colecciones y poblarse de datos adecuadamente. Debe crearse un usuario y dotarlo de los privilegios necesarios para acceder remotamente a los datos. Se proporcionará esta información al resto de los miembros del grupo.
 Los clientes deben estar siempre en máquinas diferentes de los respectivos servidores a los que acceden. Se documentará todo el proceso de configuración de los servidores.</description>
    </item>
    
    <item>
      <title>Módulo de Vbox no carga con el kernel</title>
      <link>https://alepeteporico.github.io/problemas/vagrant_kernel/</link>
      <pubDate>Sun, 04 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/problemas/vagrant_kernel/</guid>
      <description>Al intentar encender una máquina vagrant o en Vbox nos da un fallo:
 alejandrogv@AlejandroGV:~/vagrant/servicios/dhcp$ vagrant up The provider &#39;virtualbox&#39; that was requested to back the machine &#39;servidor&#39; is reporting that it isn&#39;t usable on this system. The reason is shown below: VirtualBox is complaining that the kernel module is not loaded. Please run `VBoxManage --version` or open the VirtualBox GUI to see the error message which should contain instructions on how to fix this error.</description>
    </item>
    
    <item>
      <title>Práctica de PLSQL</title>
      <link>https://alepeteporico.github.io/practicas/practica_plsql/</link>
      <pubDate>Mon, 29 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/practica_plsql/</guid>
      <description> Realiza una función que reciba el código de un aerogenerador y una fecha y devuelva el total de energía producida en esa fecha. Debes controlar las siguientes excepciones: Aerogenerador inexistente y Aerogenerador en desconexión durante ese día.  create or replace function EnergiaDiaria (v_codigo AEROGENERADORES.CODIGO%type, v_fecha) </description>
    </item>
    
    <item>
      <title>Apuntes de Libvirt</title>
      <link>https://alepeteporico.github.io/apuntes/apuntes-de-libvirt/</link>
      <pubDate>Mon, 22 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/apuntes/apuntes-de-libvirt/</guid>
      <description>Libvirt es una API de virtualizacion que se usa con KVM o Qemu KVM (el sistema de virtualización nativo de Linux).
Instalación Para instalar libvirt deberemos instalar los siguientes paquetes
sudo apt-get install qemu-kvm libvirt-daemon-system Explicación de los paquetes:
  qemu-kvm: Proporciona la virtualización para x86
  libvirt-daemon-system: Es el demonio de libvirt, el cual hace accesible la API a través de un socket UNIX (aunque se puede configurar para acceder a través de un socket TCP).</description>
    </item>
    
    <item>
      <title>Práctica mdadm y rclone</title>
      <link>https://alepeteporico.github.io/practicas/mdadm_rclone/</link>
      <pubDate>Wed, 17 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/mdadm_rclone/</guid>
      <description>RAID 5 Fichero VagrantFile:  # -*- mode: ruby -*- # vi: set ft=ruby : Vagrant.configure(&amp;quot;2&amp;quot;) do |config| config.vm.box = &amp;quot;debian/buster64&amp;quot; config.vm.hostname = &amp;quot;practica1&amp;quot; config.vm.provider :virtualbox do |v| disco = &#39;.vagrant/disco.vdi&#39; v.customize [&amp;quot;createhd&amp;quot;,&amp;quot;--filename&amp;quot;,disco,&amp;quot;--size&amp;quot;, 1024] v.customize [&amp;quot;storageattach&amp;quot;,:id,&amp;quot;--storagectl&amp;quot;,&amp;quot;SATA Controller&amp;quot;,&amp;quot;--port&amp;quot;,1,&amp;quot;--device&amp;quot;,0,&amp;quot;--type&amp;quot;,&amp;quot;hdd&amp;quot;,&amp;quot;--medium&amp;quot;,disco] disco2 = &#39;.vagrant/disco2.vdi&#39; v.customize [&amp;quot;createhd&amp;quot;,&amp;quot;--filename&amp;quot;,disco2,&amp;quot;--size&amp;quot;, 1024] v.customize [&amp;quot;storageattach&amp;quot;,:id,&amp;quot;--storagectl&amp;quot;,&amp;quot;SATA Controller&amp;quot;,&amp;quot;--port&amp;quot;,2,&amp;quot;--device&amp;quot;,0,&amp;quot;--type&amp;quot;,&amp;quot;hdd&amp;quot;,&amp;quot;--medium&amp;quot;,disco2] disco3 = &#39;.vagrant/disco3.vdi&#39; v.customize [&amp;quot;createhd&amp;quot;,&amp;quot;--filename&amp;quot;,disco3,&amp;quot;--size&amp;quot;, 1024] v.customize [&amp;quot;storageattach&amp;quot;,:id,&amp;quot;--storagectl&amp;quot;,&amp;quot;SATA Controller&amp;quot;,&amp;quot;--port&amp;quot;,3,&amp;quot;--device&amp;quot;,0,&amp;quot;--type&amp;quot;,&amp;quot;hdd&amp;quot;,&amp;quot;--medium&amp;quot;,disco3] disco4 = &#39;.vagrant/disco4.vdi&#39; v.customize [&amp;quot;createhd&amp;quot;,&amp;quot;--filename&amp;quot;,disco4,&amp;quot;--size&amp;quot;, 1024] v.customize [&amp;quot;storageattach&amp;quot;,:id,&amp;quot;--storagectl&amp;quot;,&amp;quot;SATA Controller&amp;quot;,&amp;quot;--port&amp;quot;,4,&amp;quot;--device&amp;quot;,0,&amp;quot;--type&amp;quot;,&amp;quot;hdd&amp;quot;,&amp;quot;--medium&amp;quot;,disco4] disco5 = &#39;.vagrant/disco5.vdi&#39; v.customize [&amp;quot;createhd&amp;quot;,&amp;quot;--filename&amp;quot;,disco5,&amp;quot;--size&amp;quot;, 1024] v.</description>
    </item>
    
    <item>
      <title>Configuración del escenario en OpenStack</title>
      <link>https://alepeteporico.github.io/practicas/escenearioos/</link>
      <pubDate>Tue, 16 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/escenearioos/</guid>
      <description>El escenario que debemos montar es el siguiente:
Nosotros tenemos nuestra propia red, pero debemos crear dos nuevas para el escenario y añadir las redes conrrespondientes a sus máquinas
Nuestro siguiente paso será deshabilitar los puertos de Dulcinea que será la máquina que usaremos para conectarnos a las demás y salir al exterior Para este proposito usaremos OpenStack Client alejandrogv@AlejandroGV:~$ source Escritorio/ASIR/hlc/openstackclient/bin/activate source ~/Descargas/Proyecto\ de\ a.gutierrez-openrc.sh
Ahora listaremos las interfaces que tenemos en nuestro proyecto</description>
    </item>
    
    <item>
      <title>Servidor DHCP</title>
      <link>https://alepeteporico.github.io/practicas/dhcp/</link>
      <pubDate>Tue, 16 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/dhcp/</guid>
      <description>Lee el documento Teoría: Servidor DHCP y explica el funcionamiento del servidor DHCP resumido en este gráfico.  En primer lugar el cliente manda una petición DHCPDISCOVER en cuanto se inicia, ya que no tiene configuración de IP usa esta petición para ver si hay un servidor DHCP que pueda darle una dirección.
Después de esto el cliente esperará en estado SELECTING y recibirá las ofertas DHCPOFFER del servidor o servidores DHCP que pueda haber en nuestra red local.</description>
    </item>
    
    <item>
      <title>Actualización de CentOS 7 a CentOS 8</title>
      <link>https://alepeteporico.github.io/practicas/centos8/</link>
      <pubDate>Fri, 19 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/centos8/</guid>
      <description>Antes de comenzar debemos instalar si no las tenemos ya las siguientes herramientas:
 [centos@quijote ~]$ sudo yum install epel-release -y [centos@quijote ~]$ sudo yum install yum-utils -y [centos@quijote ~]$ sudo yum install rpmconf -y  Ahora usaremos rpmconf para verificar conflictos en ficheros de configuración:
 [centos@quijote ~]$ sudo rpmconf -a  Limpiamos los paquetes innecesarios:
 [centos@quijote ~]$ sudo package-cleanup --leaves [centos@quijote ~]$ sudo package-cleanup --orphans  Instalamos el nuevo gestor de paquetes que usa CentOS 8, dnf:</description>
    </item>
    
    <item>
      <title>Implantanción y despliegue de una web estática</title>
      <link>https://alepeteporico.github.io/practicas/pagina_est%C3%A1tica/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/pagina_est%C3%A1tica/</guid>
      <description>La instalación es tan sencilla como usar apt:
sudo apt install hugo  Una vez instalado el siguiente paso sería crear un sitio web:
hugo new site [nombre]  Esto creará una carpeta donde podremos configurar nuestra página, para ello primero descargaremos desde la página oficial de hugo un tema. Debemos fijarnos que se corresponde con nuestra versión de hugo o es inferior, si elegimos una plantilla que necesite una versión de hugo superior dará problemas.</description>
    </item>
    
    <item>
      <title>About Hugo</title>
      <link>https://alepeteporico.github.io/about/</link>
      <pubDate>Wed, 09 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/about/</guid>
      <description>Hugo is a static site engine written in Go.
It makes use of a variety of open source projects including:
 Cobra Viper J Walter Weatherman Cast  Learn more and contribute on GitHub.
Setup Some fun facts about Hugo:
 Built in Go Loosely inspired by Jekyll Primarily developed by spf13 on the train while commuting to and from Manhattan. Coded in Vim using spf13-vim  Have questions or suggestions?</description>
    </item>
    
    <item>
      <title>Servidor LEMP</title>
      <link>https://alepeteporico.github.io/practicas/lemp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://alepeteporico.github.io/practicas/lemp/</guid>
      <description>Vamos a instalar todos los paquetes necesarios.  debian@mrrobot:~$ sudo apt install nginx mariadb-client mariadb-server php php-mysql php-fpm  También debemos instalar el servidor de aplicaciones php-fpm.  debian@mrrobot:~$ sudo apt install php7.4-fpm php7.4 Virtualhosting  Crearemos un virtual host en sites-available  server { listen 80; listen [::]:80; root /var/www/web; index index.html index.htm index.nginx-debian.html; server_name www.alejandrogv.site; location / { try_files $uri $uri/ =404; } }  Para que nuestro virtualhost por defecto sea este, debemos añadir la siguiente línea el el fichero default de el directorio sites-available, dentro del bloque server.</description>
    </item>
    
  </channel>
</rss>
